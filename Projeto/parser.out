Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARROW
    ASSIGN
    BINARY_NUMBER
    BITWISE_AND
    BITWISE_AND_ASSIGN
    BITWISE_COMPLEMENT
    BITWISE_OR
    BITWISE_OR_ASSIGN
    BITWISE_SHIFT_LEFT
    BITWISE_SHIFT_RIGHT
    BITWISE_XOR
    BITWISE_XOR_ASSIGN
    CHARACTER
    COLON
    COMMENT
    DECREMENT
    DIVIDE
    DIVIDE_ASSIGN
    DOT
    EQUALS_THEN
    FLOAT_NUMBER
    GREATER_EQUALS
    GREATER_THEN
    HEXADECIMAL_NUMBER
    INCREMENT
    KEYWORD_AUTO
    KEYWORD_BREAK
    KEYWORD_CASE
    KEYWORD_CONST
    KEYWORD_CONTINUE
    KEYWORD_DEFAULT
    KEYWORD_DO
    KEYWORD_ELSE
    KEYWORD_ENUM
    KEYWORD_EXTERN
    KEYWORD_FOR
    KEYWORD_GOTO
    KEYWORD_IF
    KEYWORD_REGISTER
    KEYWORD_RETURN
    KEYWORD_SIGNED
    KEYWORD_SIZEOF
    KEYWORD_STATIC
    KEYWORD_STRUCT
    KEYWORD_SWITCH
    KEYWORD_TYPEDEF
    KEYWORD_UNION
    KEYWORD_UNSIGNED
    KEYWORD_VOLATILE
    KEYWORD_WHILE
    LESS_EQUALS
    LESS_THEN
    LOGICAL_AND
    LOGICAL_OR
    MINUS
    MINUS_ASSIGN
    MODULUS
    MODULUS_ASSIGN
    MULTILINE_COMMENT
    NOT
    NOT_EQUALS
    OCTAL_NUMBER
    PLUS
    PLUS_ASSIGN
    PRE_PROCESSOR
    QUESTION_MARK
    SHIFT_LEFT_ASSIGN
    SHIFT_RIGHT_ASSIGN
    STRING
    TIMES_ASSIGN

Grammar

Rule 0     S' -> program
Rule 1     program -> function_declaration program
Rule 2     program -> function program
Rule 3     program -> empty
Rule 4     function_declaration -> signature SEMICOLON
Rule 5     command_block -> LBRACE commands RBRACE
Rule 6     command_block -> LBRACE RBRACE
Rule 7     commands -> command commands
Rule 8     commands -> empty
Rule 9     command -> data_definition SEMICOLON
Rule 10    function -> signature command_block
Rule 11    signature -> type IDENTIFIER function_parameters
Rule 12    signature -> pointer IDENTIFIER function_parameters
Rule 13    function_parameters -> LPAREN parameters_list RPAREN
Rule 14    parameters_list -> data_definition COMMA parameters_list
Rule 15    parameters_list -> data_definition
Rule 16    parameters_list -> array_definition
Rule 17    parameters_list -> array_declaration
Rule 18    parameters_list -> empty
Rule 19    array_declaration -> type IDENTIFIER LBRACKET RBRACKET
Rule 20    array_declaration -> pointer IDENTIFIER LBRACKET RBRACKET
Rule 21    data_definition -> type IDENTIFIER
Rule 22    data_definition -> pointer IDENTIFIER
Rule 23    array_definition -> static_array_definition
Rule 24    array_definition -> runtime_array_definition
Rule 25    static_array_definition -> type IDENTIFIER LBRACKET NUMBER RBRACKET
Rule 26    static_array_definition -> pointer IDENTIFIER LBRACKET NUMBER RBRACKET
Rule 27    runtime_array_definition -> type IDENTIFIER LBRACKET IDENTIFIER RBRACKET
Rule 28    runtime_array_definition -> pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET
Rule 29    type -> TYPE_CHAR
Rule 30    type -> TYPE_DOUBLE
Rule 31    type -> TYPE_FLOAT
Rule 32    type -> TYPE_INT
Rule 33    type -> TYPE_LONG
Rule 34    type -> TYPE_SHORT
Rule 35    type -> TYPE_VOID
Rule 36    pointer -> type TIMES multiple_pointer
Rule 37    multiple_pointer -> TIMES multiple_pointer
Rule 38    multiple_pointer -> empty
Rule 39    empty -> <empty>

Terminals, with rules where they appear

ARROW                : 
ASSIGN               : 
BINARY_NUMBER        : 
BITWISE_AND          : 
BITWISE_AND_ASSIGN   : 
BITWISE_COMPLEMENT   : 
BITWISE_OR           : 
BITWISE_OR_ASSIGN    : 
BITWISE_SHIFT_LEFT   : 
BITWISE_SHIFT_RIGHT  : 
BITWISE_XOR          : 
BITWISE_XOR_ASSIGN   : 
CHARACTER            : 
COLON                : 
COMMA                : 14
COMMENT              : 
DECREMENT            : 
DIVIDE               : 
DIVIDE_ASSIGN        : 
DOT                  : 
EQUALS_THEN          : 
FLOAT_NUMBER         : 
GREATER_EQUALS       : 
GREATER_THEN         : 
HEXADECIMAL_NUMBER   : 
IDENTIFIER           : 11 12 19 20 21 22 25 26 27 27 28 28
INCREMENT            : 
KEYWORD_AUTO         : 
KEYWORD_BREAK        : 
KEYWORD_CASE         : 
KEYWORD_CONST        : 
KEYWORD_CONTINUE     : 
KEYWORD_DEFAULT      : 
KEYWORD_DO           : 
KEYWORD_ELSE         : 
KEYWORD_ENUM         : 
KEYWORD_EXTERN       : 
KEYWORD_FOR          : 
KEYWORD_GOTO         : 
KEYWORD_IF           : 
KEYWORD_REGISTER     : 
KEYWORD_RETURN       : 
KEYWORD_SIGNED       : 
KEYWORD_SIZEOF       : 
KEYWORD_STATIC       : 
KEYWORD_STRUCT       : 
KEYWORD_SWITCH       : 
KEYWORD_TYPEDEF      : 
KEYWORD_UNION        : 
KEYWORD_UNSIGNED     : 
KEYWORD_VOLATILE     : 
KEYWORD_WHILE        : 
LBRACE               : 5 6
LBRACKET             : 19 20 25 26 27 28
LESS_EQUALS          : 
LESS_THEN            : 
LOGICAL_AND          : 
LOGICAL_OR           : 
LPAREN               : 13
MINUS                : 
MINUS_ASSIGN         : 
MODULUS              : 
MODULUS_ASSIGN       : 
MULTILINE_COMMENT    : 
NOT                  : 
NOT_EQUALS           : 
NUMBER               : 25 26
OCTAL_NUMBER         : 
PLUS                 : 
PLUS_ASSIGN          : 
PRE_PROCESSOR        : 
QUESTION_MARK        : 
RBRACE               : 5 6
RBRACKET             : 19 20 25 26 27 28
RPAREN               : 13
SEMICOLON            : 4 9
SHIFT_LEFT_ASSIGN    : 
SHIFT_RIGHT_ASSIGN   : 
STRING               : 
TIMES                : 36 37
TIMES_ASSIGN         : 
TYPE_CHAR            : 29
TYPE_DOUBLE          : 30
TYPE_FLOAT           : 31
TYPE_INT             : 32
TYPE_LONG            : 33
TYPE_SHORT           : 34
TYPE_VOID            : 35
error                : 

Nonterminals, with rules where they appear

array_declaration    : 17
array_definition     : 16
command              : 7
command_block        : 10
commands             : 5 7
data_definition      : 9 14 15
empty                : 3 8 18 38
function             : 2
function_declaration : 1
function_parameters  : 11 12
multiple_pointer     : 36 37
parameters_list      : 13 14
pointer              : 12 20 22 26 28
program              : 1 2 0
runtime_array_definition : 24
signature            : 4 10
static_array_definition : 23
type                 : 11 19 21 25 27 36

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . function_declaration program
    (2) program -> . function program
    (3) program -> . empty
    (4) function_declaration -> . signature SEMICOLON
    (10) function -> . signature command_block
    (39) empty -> .
    (11) signature -> . type IDENTIFIER function_parameters
    (12) signature -> . pointer IDENTIFIER function_parameters
    (29) type -> . TYPE_CHAR
    (30) type -> . TYPE_DOUBLE
    (31) type -> . TYPE_FLOAT
    (32) type -> . TYPE_INT
    (33) type -> . TYPE_LONG
    (34) type -> . TYPE_SHORT
    (35) type -> . TYPE_VOID
    (36) pointer -> . type TIMES multiple_pointer

    $end            reduce using rule 39 (empty -> .)
    TYPE_CHAR       shift and go to state 8
    TYPE_DOUBLE     shift and go to state 9
    TYPE_FLOAT      shift and go to state 10
    TYPE_INT        shift and go to state 11
    TYPE_LONG       shift and go to state 12
    TYPE_SHORT      shift and go to state 13
    TYPE_VOID       shift and go to state 14

    program                        shift and go to state 1
    function_declaration           shift and go to state 2
    function                       shift and go to state 3
    empty                          shift and go to state 4
    signature                      shift and go to state 5
    type                           shift and go to state 6
    pointer                        shift and go to state 7

state 1

    (0) S' -> program .



state 2

    (1) program -> function_declaration . program
    (1) program -> . function_declaration program
    (2) program -> . function program
    (3) program -> . empty
    (4) function_declaration -> . signature SEMICOLON
    (10) function -> . signature command_block
    (39) empty -> .
    (11) signature -> . type IDENTIFIER function_parameters
    (12) signature -> . pointer IDENTIFIER function_parameters
    (29) type -> . TYPE_CHAR
    (30) type -> . TYPE_DOUBLE
    (31) type -> . TYPE_FLOAT
    (32) type -> . TYPE_INT
    (33) type -> . TYPE_LONG
    (34) type -> . TYPE_SHORT
    (35) type -> . TYPE_VOID
    (36) pointer -> . type TIMES multiple_pointer

    $end            reduce using rule 39 (empty -> .)
    TYPE_CHAR       shift and go to state 8
    TYPE_DOUBLE     shift and go to state 9
    TYPE_FLOAT      shift and go to state 10
    TYPE_INT        shift and go to state 11
    TYPE_LONG       shift and go to state 12
    TYPE_SHORT      shift and go to state 13
    TYPE_VOID       shift and go to state 14

    function_declaration           shift and go to state 2
    program                        shift and go to state 15
    function                       shift and go to state 3
    empty                          shift and go to state 4
    signature                      shift and go to state 5
    type                           shift and go to state 6
    pointer                        shift and go to state 7

state 3

    (2) program -> function . program
    (1) program -> . function_declaration program
    (2) program -> . function program
    (3) program -> . empty
    (4) function_declaration -> . signature SEMICOLON
    (10) function -> . signature command_block
    (39) empty -> .
    (11) signature -> . type IDENTIFIER function_parameters
    (12) signature -> . pointer IDENTIFIER function_parameters
    (29) type -> . TYPE_CHAR
    (30) type -> . TYPE_DOUBLE
    (31) type -> . TYPE_FLOAT
    (32) type -> . TYPE_INT
    (33) type -> . TYPE_LONG
    (34) type -> . TYPE_SHORT
    (35) type -> . TYPE_VOID
    (36) pointer -> . type TIMES multiple_pointer

    $end            reduce using rule 39 (empty -> .)
    TYPE_CHAR       shift and go to state 8
    TYPE_DOUBLE     shift and go to state 9
    TYPE_FLOAT      shift and go to state 10
    TYPE_INT        shift and go to state 11
    TYPE_LONG       shift and go to state 12
    TYPE_SHORT      shift and go to state 13
    TYPE_VOID       shift and go to state 14

    function                       shift and go to state 3
    program                        shift and go to state 16
    function_declaration           shift and go to state 2
    empty                          shift and go to state 4
    signature                      shift and go to state 5
    type                           shift and go to state 6
    pointer                        shift and go to state 7

state 4

    (3) program -> empty .

    $end            reduce using rule 3 (program -> empty .)


state 5

    (4) function_declaration -> signature . SEMICOLON
    (10) function -> signature . command_block
    (5) command_block -> . LBRACE commands RBRACE
    (6) command_block -> . LBRACE RBRACE

    SEMICOLON       shift and go to state 17
    LBRACE          shift and go to state 19

    command_block                  shift and go to state 18

state 6

    (11) signature -> type . IDENTIFIER function_parameters
    (36) pointer -> type . TIMES multiple_pointer

    IDENTIFIER      shift and go to state 20
    TIMES           shift and go to state 21


state 7

    (12) signature -> pointer . IDENTIFIER function_parameters

    IDENTIFIER      shift and go to state 22


state 8

    (29) type -> TYPE_CHAR .

    IDENTIFIER      reduce using rule 29 (type -> TYPE_CHAR .)
    TIMES           reduce using rule 29 (type -> TYPE_CHAR .)


state 9

    (30) type -> TYPE_DOUBLE .

    IDENTIFIER      reduce using rule 30 (type -> TYPE_DOUBLE .)
    TIMES           reduce using rule 30 (type -> TYPE_DOUBLE .)


state 10

    (31) type -> TYPE_FLOAT .

    IDENTIFIER      reduce using rule 31 (type -> TYPE_FLOAT .)
    TIMES           reduce using rule 31 (type -> TYPE_FLOAT .)


state 11

    (32) type -> TYPE_INT .

    IDENTIFIER      reduce using rule 32 (type -> TYPE_INT .)
    TIMES           reduce using rule 32 (type -> TYPE_INT .)


state 12

    (33) type -> TYPE_LONG .

    IDENTIFIER      reduce using rule 33 (type -> TYPE_LONG .)
    TIMES           reduce using rule 33 (type -> TYPE_LONG .)


state 13

    (34) type -> TYPE_SHORT .

    IDENTIFIER      reduce using rule 34 (type -> TYPE_SHORT .)
    TIMES           reduce using rule 34 (type -> TYPE_SHORT .)


state 14

    (35) type -> TYPE_VOID .

    IDENTIFIER      reduce using rule 35 (type -> TYPE_VOID .)
    TIMES           reduce using rule 35 (type -> TYPE_VOID .)


state 15

    (1) program -> function_declaration program .

    $end            reduce using rule 1 (program -> function_declaration program .)


state 16

    (2) program -> function program .

    $end            reduce using rule 2 (program -> function program .)


state 17

    (4) function_declaration -> signature SEMICOLON .

    TYPE_CHAR       reduce using rule 4 (function_declaration -> signature SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 4 (function_declaration -> signature SEMICOLON .)
    TYPE_FLOAT      reduce using rule 4 (function_declaration -> signature SEMICOLON .)
    TYPE_INT        reduce using rule 4 (function_declaration -> signature SEMICOLON .)
    TYPE_LONG       reduce using rule 4 (function_declaration -> signature SEMICOLON .)
    TYPE_SHORT      reduce using rule 4 (function_declaration -> signature SEMICOLON .)
    TYPE_VOID       reduce using rule 4 (function_declaration -> signature SEMICOLON .)
    $end            reduce using rule 4 (function_declaration -> signature SEMICOLON .)


state 18

    (10) function -> signature command_block .

    TYPE_CHAR       reduce using rule 10 (function -> signature command_block .)
    TYPE_DOUBLE     reduce using rule 10 (function -> signature command_block .)
    TYPE_FLOAT      reduce using rule 10 (function -> signature command_block .)
    TYPE_INT        reduce using rule 10 (function -> signature command_block .)
    TYPE_LONG       reduce using rule 10 (function -> signature command_block .)
    TYPE_SHORT      reduce using rule 10 (function -> signature command_block .)
    TYPE_VOID       reduce using rule 10 (function -> signature command_block .)
    $end            reduce using rule 10 (function -> signature command_block .)


state 19

    (5) command_block -> LBRACE . commands RBRACE
    (6) command_block -> LBRACE . RBRACE
    (7) commands -> . command commands
    (8) commands -> . empty
    (9) command -> . data_definition SEMICOLON
    (39) empty -> .
    (21) data_definition -> . type IDENTIFIER
    (22) data_definition -> . pointer IDENTIFIER
    (29) type -> . TYPE_CHAR
    (30) type -> . TYPE_DOUBLE
    (31) type -> . TYPE_FLOAT
    (32) type -> . TYPE_INT
    (33) type -> . TYPE_LONG
    (34) type -> . TYPE_SHORT
    (35) type -> . TYPE_VOID
    (36) pointer -> . type TIMES multiple_pointer

  ! shift/reduce conflict for RBRACE resolved as shift
    RBRACE          shift and go to state 24
    TYPE_CHAR       shift and go to state 8
    TYPE_DOUBLE     shift and go to state 9
    TYPE_FLOAT      shift and go to state 10
    TYPE_INT        shift and go to state 11
    TYPE_LONG       shift and go to state 12
    TYPE_SHORT      shift and go to state 13
    TYPE_VOID       shift and go to state 14

  ! RBRACE          [ reduce using rule 39 (empty -> .) ]

    commands                       shift and go to state 23
    command                        shift and go to state 25
    empty                          shift and go to state 26
    data_definition                shift and go to state 27
    type                           shift and go to state 28
    pointer                        shift and go to state 29

state 20

    (11) signature -> type IDENTIFIER . function_parameters
    (13) function_parameters -> . LPAREN parameters_list RPAREN

    LPAREN          shift and go to state 31

    function_parameters            shift and go to state 30

state 21

    (36) pointer -> type TIMES . multiple_pointer
    (37) multiple_pointer -> . TIMES multiple_pointer
    (38) multiple_pointer -> . empty
    (39) empty -> .

    TIMES           shift and go to state 32
    IDENTIFIER      reduce using rule 39 (empty -> .)

    multiple_pointer               shift and go to state 33
    empty                          shift and go to state 34

state 22

    (12) signature -> pointer IDENTIFIER . function_parameters
    (13) function_parameters -> . LPAREN parameters_list RPAREN

    LPAREN          shift and go to state 31

    function_parameters            shift and go to state 35

state 23

    (5) command_block -> LBRACE commands . RBRACE

    RBRACE          shift and go to state 36


state 24

    (6) command_block -> LBRACE RBRACE .

    TYPE_CHAR       reduce using rule 6 (command_block -> LBRACE RBRACE .)
    TYPE_DOUBLE     reduce using rule 6 (command_block -> LBRACE RBRACE .)
    TYPE_FLOAT      reduce using rule 6 (command_block -> LBRACE RBRACE .)
    TYPE_INT        reduce using rule 6 (command_block -> LBRACE RBRACE .)
    TYPE_LONG       reduce using rule 6 (command_block -> LBRACE RBRACE .)
    TYPE_SHORT      reduce using rule 6 (command_block -> LBRACE RBRACE .)
    TYPE_VOID       reduce using rule 6 (command_block -> LBRACE RBRACE .)
    $end            reduce using rule 6 (command_block -> LBRACE RBRACE .)


state 25

    (7) commands -> command . commands
    (7) commands -> . command commands
    (8) commands -> . empty
    (9) command -> . data_definition SEMICOLON
    (39) empty -> .
    (21) data_definition -> . type IDENTIFIER
    (22) data_definition -> . pointer IDENTIFIER
    (29) type -> . TYPE_CHAR
    (30) type -> . TYPE_DOUBLE
    (31) type -> . TYPE_FLOAT
    (32) type -> . TYPE_INT
    (33) type -> . TYPE_LONG
    (34) type -> . TYPE_SHORT
    (35) type -> . TYPE_VOID
    (36) pointer -> . type TIMES multiple_pointer

    RBRACE          reduce using rule 39 (empty -> .)
    TYPE_CHAR       shift and go to state 8
    TYPE_DOUBLE     shift and go to state 9
    TYPE_FLOAT      shift and go to state 10
    TYPE_INT        shift and go to state 11
    TYPE_LONG       shift and go to state 12
    TYPE_SHORT      shift and go to state 13
    TYPE_VOID       shift and go to state 14

    command                        shift and go to state 25
    commands                       shift and go to state 37
    empty                          shift and go to state 26
    data_definition                shift and go to state 27
    type                           shift and go to state 28
    pointer                        shift and go to state 29

state 26

    (8) commands -> empty .

    RBRACE          reduce using rule 8 (commands -> empty .)


state 27

    (9) command -> data_definition . SEMICOLON

    SEMICOLON       shift and go to state 38


state 28

    (21) data_definition -> type . IDENTIFIER
    (36) pointer -> type . TIMES multiple_pointer

    IDENTIFIER      shift and go to state 39
    TIMES           shift and go to state 21


state 29

    (22) data_definition -> pointer . IDENTIFIER

    IDENTIFIER      shift and go to state 40


state 30

    (11) signature -> type IDENTIFIER function_parameters .

    SEMICOLON       reduce using rule 11 (signature -> type IDENTIFIER function_parameters .)
    LBRACE          reduce using rule 11 (signature -> type IDENTIFIER function_parameters .)


state 31

    (13) function_parameters -> LPAREN . parameters_list RPAREN
    (14) parameters_list -> . data_definition COMMA parameters_list
    (15) parameters_list -> . data_definition
    (16) parameters_list -> . array_definition
    (17) parameters_list -> . array_declaration
    (18) parameters_list -> . empty
    (21) data_definition -> . type IDENTIFIER
    (22) data_definition -> . pointer IDENTIFIER
    (23) array_definition -> . static_array_definition
    (24) array_definition -> . runtime_array_definition
    (19) array_declaration -> . type IDENTIFIER LBRACKET RBRACKET
    (20) array_declaration -> . pointer IDENTIFIER LBRACKET RBRACKET
    (39) empty -> .
    (29) type -> . TYPE_CHAR
    (30) type -> . TYPE_DOUBLE
    (31) type -> . TYPE_FLOAT
    (32) type -> . TYPE_INT
    (33) type -> . TYPE_LONG
    (34) type -> . TYPE_SHORT
    (35) type -> . TYPE_VOID
    (36) pointer -> . type TIMES multiple_pointer
    (25) static_array_definition -> . type IDENTIFIER LBRACKET NUMBER RBRACKET
    (26) static_array_definition -> . pointer IDENTIFIER LBRACKET NUMBER RBRACKET
    (27) runtime_array_definition -> . type IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (28) runtime_array_definition -> . pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    RPAREN          reduce using rule 39 (empty -> .)
    TYPE_CHAR       shift and go to state 8
    TYPE_DOUBLE     shift and go to state 9
    TYPE_FLOAT      shift and go to state 10
    TYPE_INT        shift and go to state 11
    TYPE_LONG       shift and go to state 12
    TYPE_SHORT      shift and go to state 13
    TYPE_VOID       shift and go to state 14

    parameters_list                shift and go to state 41
    data_definition                shift and go to state 42
    array_definition               shift and go to state 43
    array_declaration              shift and go to state 44
    empty                          shift and go to state 45
    type                           shift and go to state 46
    pointer                        shift and go to state 47
    static_array_definition        shift and go to state 48
    runtime_array_definition       shift and go to state 49

state 32

    (37) multiple_pointer -> TIMES . multiple_pointer
    (37) multiple_pointer -> . TIMES multiple_pointer
    (38) multiple_pointer -> . empty
    (39) empty -> .

    TIMES           shift and go to state 32
    IDENTIFIER      reduce using rule 39 (empty -> .)

    multiple_pointer               shift and go to state 50
    empty                          shift and go to state 34

state 33

    (36) pointer -> type TIMES multiple_pointer .

    IDENTIFIER      reduce using rule 36 (pointer -> type TIMES multiple_pointer .)


state 34

    (38) multiple_pointer -> empty .

    IDENTIFIER      reduce using rule 38 (multiple_pointer -> empty .)


state 35

    (12) signature -> pointer IDENTIFIER function_parameters .

    SEMICOLON       reduce using rule 12 (signature -> pointer IDENTIFIER function_parameters .)
    LBRACE          reduce using rule 12 (signature -> pointer IDENTIFIER function_parameters .)


state 36

    (5) command_block -> LBRACE commands RBRACE .

    TYPE_CHAR       reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    TYPE_DOUBLE     reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    TYPE_FLOAT      reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    TYPE_INT        reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    TYPE_LONG       reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    TYPE_SHORT      reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    TYPE_VOID       reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    $end            reduce using rule 5 (command_block -> LBRACE commands RBRACE .)


state 37

    (7) commands -> command commands .

    RBRACE          reduce using rule 7 (commands -> command commands .)


state 38

    (9) command -> data_definition SEMICOLON .

    TYPE_CHAR       reduce using rule 9 (command -> data_definition SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 9 (command -> data_definition SEMICOLON .)
    TYPE_FLOAT      reduce using rule 9 (command -> data_definition SEMICOLON .)
    TYPE_INT        reduce using rule 9 (command -> data_definition SEMICOLON .)
    TYPE_LONG       reduce using rule 9 (command -> data_definition SEMICOLON .)
    TYPE_SHORT      reduce using rule 9 (command -> data_definition SEMICOLON .)
    TYPE_VOID       reduce using rule 9 (command -> data_definition SEMICOLON .)
    RBRACE          reduce using rule 9 (command -> data_definition SEMICOLON .)


state 39

    (21) data_definition -> type IDENTIFIER .

    SEMICOLON       reduce using rule 21 (data_definition -> type IDENTIFIER .)


state 40

    (22) data_definition -> pointer IDENTIFIER .

    SEMICOLON       reduce using rule 22 (data_definition -> pointer IDENTIFIER .)


state 41

    (13) function_parameters -> LPAREN parameters_list . RPAREN

    RPAREN          shift and go to state 51


state 42

    (14) parameters_list -> data_definition . COMMA parameters_list
    (15) parameters_list -> data_definition .

    COMMA           shift and go to state 52
    RPAREN          reduce using rule 15 (parameters_list -> data_definition .)


state 43

    (16) parameters_list -> array_definition .

    RPAREN          reduce using rule 16 (parameters_list -> array_definition .)


state 44

    (17) parameters_list -> array_declaration .

    RPAREN          reduce using rule 17 (parameters_list -> array_declaration .)


state 45

    (18) parameters_list -> empty .

    RPAREN          reduce using rule 18 (parameters_list -> empty .)


state 46

    (21) data_definition -> type . IDENTIFIER
    (19) array_declaration -> type . IDENTIFIER LBRACKET RBRACKET
    (36) pointer -> type . TIMES multiple_pointer
    (25) static_array_definition -> type . IDENTIFIER LBRACKET NUMBER RBRACKET
    (27) runtime_array_definition -> type . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    IDENTIFIER      shift and go to state 53
    TIMES           shift and go to state 21


state 47

    (22) data_definition -> pointer . IDENTIFIER
    (20) array_declaration -> pointer . IDENTIFIER LBRACKET RBRACKET
    (26) static_array_definition -> pointer . IDENTIFIER LBRACKET NUMBER RBRACKET
    (28) runtime_array_definition -> pointer . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    IDENTIFIER      shift and go to state 54


state 48

    (23) array_definition -> static_array_definition .

    RPAREN          reduce using rule 23 (array_definition -> static_array_definition .)


state 49

    (24) array_definition -> runtime_array_definition .

    RPAREN          reduce using rule 24 (array_definition -> runtime_array_definition .)


state 50

    (37) multiple_pointer -> TIMES multiple_pointer .

    IDENTIFIER      reduce using rule 37 (multiple_pointer -> TIMES multiple_pointer .)


state 51

    (13) function_parameters -> LPAREN parameters_list RPAREN .

    SEMICOLON       reduce using rule 13 (function_parameters -> LPAREN parameters_list RPAREN .)
    LBRACE          reduce using rule 13 (function_parameters -> LPAREN parameters_list RPAREN .)


state 52

    (14) parameters_list -> data_definition COMMA . parameters_list
    (14) parameters_list -> . data_definition COMMA parameters_list
    (15) parameters_list -> . data_definition
    (16) parameters_list -> . array_definition
    (17) parameters_list -> . array_declaration
    (18) parameters_list -> . empty
    (21) data_definition -> . type IDENTIFIER
    (22) data_definition -> . pointer IDENTIFIER
    (23) array_definition -> . static_array_definition
    (24) array_definition -> . runtime_array_definition
    (19) array_declaration -> . type IDENTIFIER LBRACKET RBRACKET
    (20) array_declaration -> . pointer IDENTIFIER LBRACKET RBRACKET
    (39) empty -> .
    (29) type -> . TYPE_CHAR
    (30) type -> . TYPE_DOUBLE
    (31) type -> . TYPE_FLOAT
    (32) type -> . TYPE_INT
    (33) type -> . TYPE_LONG
    (34) type -> . TYPE_SHORT
    (35) type -> . TYPE_VOID
    (36) pointer -> . type TIMES multiple_pointer
    (25) static_array_definition -> . type IDENTIFIER LBRACKET NUMBER RBRACKET
    (26) static_array_definition -> . pointer IDENTIFIER LBRACKET NUMBER RBRACKET
    (27) runtime_array_definition -> . type IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (28) runtime_array_definition -> . pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    RPAREN          reduce using rule 39 (empty -> .)
    TYPE_CHAR       shift and go to state 8
    TYPE_DOUBLE     shift and go to state 9
    TYPE_FLOAT      shift and go to state 10
    TYPE_INT        shift and go to state 11
    TYPE_LONG       shift and go to state 12
    TYPE_SHORT      shift and go to state 13
    TYPE_VOID       shift and go to state 14

    data_definition                shift and go to state 42
    parameters_list                shift and go to state 55
    array_definition               shift and go to state 43
    array_declaration              shift and go to state 44
    empty                          shift and go to state 45
    type                           shift and go to state 46
    pointer                        shift and go to state 47
    static_array_definition        shift and go to state 48
    runtime_array_definition       shift and go to state 49

state 53

    (21) data_definition -> type IDENTIFIER .
    (19) array_declaration -> type IDENTIFIER . LBRACKET RBRACKET
    (25) static_array_definition -> type IDENTIFIER . LBRACKET NUMBER RBRACKET
    (27) runtime_array_definition -> type IDENTIFIER . LBRACKET IDENTIFIER RBRACKET

    COMMA           reduce using rule 21 (data_definition -> type IDENTIFIER .)
    RPAREN          reduce using rule 21 (data_definition -> type IDENTIFIER .)
    LBRACKET        shift and go to state 56


state 54

    (22) data_definition -> pointer IDENTIFIER .
    (20) array_declaration -> pointer IDENTIFIER . LBRACKET RBRACKET
    (26) static_array_definition -> pointer IDENTIFIER . LBRACKET NUMBER RBRACKET
    (28) runtime_array_definition -> pointer IDENTIFIER . LBRACKET IDENTIFIER RBRACKET

    COMMA           reduce using rule 22 (data_definition -> pointer IDENTIFIER .)
    RPAREN          reduce using rule 22 (data_definition -> pointer IDENTIFIER .)
    LBRACKET        shift and go to state 57


state 55

    (14) parameters_list -> data_definition COMMA parameters_list .

    RPAREN          reduce using rule 14 (parameters_list -> data_definition COMMA parameters_list .)


state 56

    (19) array_declaration -> type IDENTIFIER LBRACKET . RBRACKET
    (25) static_array_definition -> type IDENTIFIER LBRACKET . NUMBER RBRACKET
    (27) runtime_array_definition -> type IDENTIFIER LBRACKET . IDENTIFIER RBRACKET

    RBRACKET        shift and go to state 59
    NUMBER          shift and go to state 60
    IDENTIFIER      shift and go to state 58


state 57

    (20) array_declaration -> pointer IDENTIFIER LBRACKET . RBRACKET
    (26) static_array_definition -> pointer IDENTIFIER LBRACKET . NUMBER RBRACKET
    (28) runtime_array_definition -> pointer IDENTIFIER LBRACKET . IDENTIFIER RBRACKET

    RBRACKET        shift and go to state 62
    NUMBER          shift and go to state 63
    IDENTIFIER      shift and go to state 61


state 58

    (27) runtime_array_definition -> type IDENTIFIER LBRACKET IDENTIFIER . RBRACKET

    RBRACKET        shift and go to state 64


state 59

    (19) array_declaration -> type IDENTIFIER LBRACKET RBRACKET .

    RPAREN          reduce using rule 19 (array_declaration -> type IDENTIFIER LBRACKET RBRACKET .)


state 60

    (25) static_array_definition -> type IDENTIFIER LBRACKET NUMBER . RBRACKET

    RBRACKET        shift and go to state 65


state 61

    (28) runtime_array_definition -> pointer IDENTIFIER LBRACKET IDENTIFIER . RBRACKET

    RBRACKET        shift and go to state 66


state 62

    (20) array_declaration -> pointer IDENTIFIER LBRACKET RBRACKET .

    RPAREN          reduce using rule 20 (array_declaration -> pointer IDENTIFIER LBRACKET RBRACKET .)


state 63

    (26) static_array_definition -> pointer IDENTIFIER LBRACKET NUMBER . RBRACKET

    RBRACKET        shift and go to state 67


state 64

    (27) runtime_array_definition -> type IDENTIFIER LBRACKET IDENTIFIER RBRACKET .

    RPAREN          reduce using rule 27 (runtime_array_definition -> type IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)


state 65

    (25) static_array_definition -> type IDENTIFIER LBRACKET NUMBER RBRACKET .

    RPAREN          reduce using rule 25 (static_array_definition -> type IDENTIFIER LBRACKET NUMBER RBRACKET .)


state 66

    (28) runtime_array_definition -> pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET .

    RPAREN          reduce using rule 28 (runtime_array_definition -> pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)


state 67

    (26) static_array_definition -> pointer IDENTIFIER LBRACKET NUMBER RBRACKET .

    RPAREN          reduce using rule 26 (static_array_definition -> pointer IDENTIFIER LBRACKET NUMBER RBRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RBRACE in state 19 resolved as shift
