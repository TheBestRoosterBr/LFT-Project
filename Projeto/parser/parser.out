Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARROW
    BITWISE_AND
    BITWISE_AND_ASSIGN
    BITWISE_COMPLEMENT
    BITWISE_OR
    BITWISE_OR_ASSIGN
    BITWISE_SHIFT_LEFT
    BITWISE_SHIFT_RIGHT
    BITWISE_XOR
    BITWISE_XOR_ASSIGN
    COLON
    COMMENT
    DECREMENT
    DIVIDE_ASSIGN
    DOT
    INCREMENT
    KEYWORD_AUTO
    KEYWORD_BREAK
    KEYWORD_CASE
    KEYWORD_CONST
    KEYWORD_CONTINUE
    KEYWORD_DEFAULT
    KEYWORD_DO
    KEYWORD_ELSE
    KEYWORD_ENUM
    KEYWORD_EXTERN
    KEYWORD_FOR
    KEYWORD_GOTO
    KEYWORD_IF
    KEYWORD_REGISTER
    KEYWORD_RETURN
    KEYWORD_SIGNED
    KEYWORD_SIZEOF
    KEYWORD_STATIC
    KEYWORD_SWITCH
    KEYWORD_TYPEDEF
    KEYWORD_UNION
    KEYWORD_UNSIGNED
    KEYWORD_VOLATILE
    MINUS_ASSIGN
    MODULUS_ASSIGN
    MULTILINE_COMMENT
    PLUS_ASSIGN
    PRE_PROCESSOR
    QUESTION_MARK
    SHIFT_LEFT_ASSIGN
    SHIFT_RIGHT_ASSIGN
    TIMES_ASSIGN

Grammar

Rule 0     S' -> program
Rule 1     program -> function_declaration program
Rule 2     program -> function program
Rule 3     program -> <empty>
Rule 4     function_declaration -> signature SEMICOLON
Rule 5     command_block -> LBRACE commands RBRACE
Rule 6     command_block -> LBRACE RBRACE
Rule 7     commands -> command commands
Rule 8     commands -> command
Rule 9     command -> type IDENTIFIER SEMICOLON
Rule 10    command -> while_loop
Rule 11    command -> assign SEMICOLON
Rule 12    command -> define_and_assign SEMICOLON
Rule 13    command -> expression SEMICOLON
Rule 14    command -> command_block
Rule 15    command -> SEMICOLON
Rule 16    command -> array_definition SEMICOLON
Rule 17    while_signature -> KEYWORD_WHILE LPAREN expression RPAREN
Rule 18    while_loop -> while_signature command_block
Rule 19    while_loop -> while_signature command
Rule 20    assign -> IDENTIFIER ASSIGN expression
Rule 21    define_and_assign -> type assign
Rule 22    define_and_assign -> pointer assign
Rule 23    expression2 -> LOGICAL_AND expression
Rule 24    expression2 -> LOGICAL_OR expression
Rule 25    expression2 -> PLUS expression
Rule 26    expression2 -> MINUS expression
Rule 27    expression2 -> TIMES expression
Rule 28    expression2 -> DIVIDE expression
Rule 29    expression2 -> MODULUS expression
Rule 30    expression2 -> EQUALS_THEN expression
Rule 31    expression2 -> NOT_EQUALS expression
Rule 32    expression2 -> GREATER_THEN expression
Rule 33    expression2 -> LESS_THEN expression
Rule 34    expression2 -> LESS_EQUALS expression
Rule 35    expression2 -> GREATER_EQUALS expression
Rule 36    expression2 -> LPAREN expression RPAREN
Rule 37    expression2 -> expression
Rule 38    expression2 -> IDENTIFIER
Rule 39    expression2 -> number
Rule 40    expression2 -> STRING
Rule 41    expression2 -> CHARACTER
Rule 42    expression2 -> assign
Rule 43    expression2 -> define_and_assign
Rule 44    expression -> expression expression2
Rule 45    expression -> NOT expression
Rule 46    expression -> expression2
Rule 47    number -> NUMBER
Rule 48    number -> FLOAT_NUMBER
Rule 49    number -> BINARY_NUMBER
Rule 50    number -> HEXADECIMAL_NUMBER
Rule 51    number -> OCTAL_NUMBER
Rule 52    function -> signature command_block
Rule 53    signature -> type IDENTIFIER function_parameters
Rule 54    signature -> pointer IDENTIFIER function_parameters
Rule 55    function_parameters -> LPAREN parameters_list RPAREN
Rule 56    function_parameters -> LPAREN RPAREN
Rule 57    parameters_list -> data_definition COMMA parameters_list
Rule 58    parameters_list -> data_definition
Rule 59    parameters_list -> array_definition COMMA parameters_list
Rule 60    parameters_list -> array_definition
Rule 61    parameters_list -> array_declaration COMMA parameters_list
Rule 62    parameters_list -> array_declaration
Rule 63    array_declaration -> data_definition IDENTIFIER LBRACKET RBRACKET
Rule 64    array_definition -> data_definition IDENTIFIER multiple_bracket_array
Rule 65    sized_bracket_array -> LBRACKET IDENTIFIER RBRACKET
Rule 66    sized_bracket_array -> LBRACKET NUMBER RBRACKET
Rule 67    multiple_bracket_array -> sized_bracket_array multiple_bracket_array
Rule 68    multiple_bracket_array -> sized_bracket_array
Rule 69    type -> primitive_types
Rule 70    type -> user_types
Rule 71    primitive_types -> TYPE_CHAR
Rule 72    primitive_types -> TYPE_DOUBLE
Rule 73    primitive_types -> TYPE_FLOAT
Rule 74    primitive_types -> TYPE_INT
Rule 75    primitive_types -> TYPE_LONG
Rule 76    primitive_types -> TYPE_SHORT
Rule 77    primitive_types -> TYPE_VOID
Rule 78    user_types -> IDENTIFIER
Rule 79    user_types -> KEYWORD_STRUCT IDENTIFIER
Rule 80    pointer -> type TIMES multiple_pointer
Rule 81    pointer -> type TIMES
Rule 82    multiple_pointer -> TIMES multiple_pointer
Rule 83    multiple_pointer -> TIMES

Terminals, with rules where they appear

ARROW                : 
ASSIGN               : 20
BINARY_NUMBER        : 49
BITWISE_AND          : 
BITWISE_AND_ASSIGN   : 
BITWISE_COMPLEMENT   : 
BITWISE_OR           : 
BITWISE_OR_ASSIGN    : 
BITWISE_SHIFT_LEFT   : 
BITWISE_SHIFT_RIGHT  : 
BITWISE_XOR          : 
BITWISE_XOR_ASSIGN   : 
CHARACTER            : 41
COLON                : 
COMMA                : 57 59 61
COMMENT              : 
DECREMENT            : 
DIVIDE               : 28
DIVIDE_ASSIGN        : 
DOT                  : 
EQUALS_THEN          : 30
FLOAT_NUMBER         : 48
GREATER_EQUALS       : 35
GREATER_THEN         : 32
HEXADECIMAL_NUMBER   : 50
IDENTIFIER           : 9 20 38 53 54 63 64 65 78 79
INCREMENT            : 
KEYWORD_AUTO         : 
KEYWORD_BREAK        : 
KEYWORD_CASE         : 
KEYWORD_CONST        : 
KEYWORD_CONTINUE     : 
KEYWORD_DEFAULT      : 
KEYWORD_DO           : 
KEYWORD_ELSE         : 
KEYWORD_ENUM         : 
KEYWORD_EXTERN       : 
KEYWORD_FOR          : 
KEYWORD_GOTO         : 
KEYWORD_IF           : 
KEYWORD_REGISTER     : 
KEYWORD_RETURN       : 
KEYWORD_SIGNED       : 
KEYWORD_SIZEOF       : 
KEYWORD_STATIC       : 
KEYWORD_STRUCT       : 79
KEYWORD_SWITCH       : 
KEYWORD_TYPEDEF      : 
KEYWORD_UNION        : 
KEYWORD_UNSIGNED     : 
KEYWORD_VOLATILE     : 
KEYWORD_WHILE        : 17
LBRACE               : 5 6
LBRACKET             : 63 65 66
LESS_EQUALS          : 34
LESS_THEN            : 33
LOGICAL_AND          : 23
LOGICAL_OR           : 24
LPAREN               : 17 36 55 56
MINUS                : 26
MINUS_ASSIGN         : 
MODULUS              : 29
MODULUS_ASSIGN       : 
MULTILINE_COMMENT    : 
NOT                  : 45
NOT_EQUALS           : 31
NUMBER               : 47 66
OCTAL_NUMBER         : 51
PLUS                 : 25
PLUS_ASSIGN          : 
PRE_PROCESSOR        : 
QUESTION_MARK        : 
RBRACE               : 5 6
RBRACKET             : 63 65 66
RPAREN               : 17 36 55 56
SEMICOLON            : 4 9 11 12 13 15 16
SHIFT_LEFT_ASSIGN    : 
SHIFT_RIGHT_ASSIGN   : 
STRING               : 40
TIMES                : 27 80 81 82 83
TIMES_ASSIGN         : 
TYPE_CHAR            : 71
TYPE_DOUBLE          : 72
TYPE_FLOAT           : 73
TYPE_INT             : 74
TYPE_LONG            : 75
TYPE_SHORT           : 76
TYPE_VOID            : 77
error                : 

Nonterminals, with rules where they appear

array_declaration    : 61 62
array_definition     : 16 59 60
assign               : 11 21 22 42
command              : 7 8 19
command_block        : 14 18 52
commands             : 5 7
data_definition      : 57 58 63 64
define_and_assign    : 12 43
expression           : 13 17 20 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 44 45
expression2          : 44 46
function             : 2
function_declaration : 1
function_parameters  : 53 54
multiple_bracket_array : 64 67
multiple_pointer     : 80 82
number               : 39
parameters_list      : 55 57 59 61
pointer              : 22 54
primitive_types      : 69
program              : 1 2 0
signature            : 4 52
sized_bracket_array  : 67 68
type                 : 9 21 53 80 81
user_types           : 70
while_loop           : 10
while_signature      : 18 19

