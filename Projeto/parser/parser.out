Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARROW
    BITWISE_AND
    BITWISE_AND_ASSIGN
    BITWISE_COMPLEMENT
    BITWISE_OR
    BITWISE_OR_ASSIGN
    BITWISE_SHIFT_LEFT
    BITWISE_SHIFT_RIGHT
    BITWISE_XOR
    BITWISE_XOR_ASSIGN
    COLON
    COMMENT
    DECREMENT
    DIVIDE_ASSIGN
    DOT
    INCREMENT
    KEYWORD_AUTO
    KEYWORD_BREAK
    KEYWORD_CASE
    KEYWORD_CONST
    KEYWORD_CONTINUE
    KEYWORD_DEFAULT
    KEYWORD_DO
    KEYWORD_ELSE
    KEYWORD_ENUM
    KEYWORD_EXTERN
    KEYWORD_FOR
    KEYWORD_GOTO
    KEYWORD_IF
    KEYWORD_REGISTER
    KEYWORD_RETURN
    KEYWORD_SIGNED
    KEYWORD_SIZEOF
    KEYWORD_STATIC
    KEYWORD_SWITCH
    KEYWORD_TYPEDEF
    KEYWORD_UNION
    KEYWORD_UNSIGNED
    KEYWORD_VOLATILE
    MINUS_ASSIGN
    MODULUS_ASSIGN
    MULTILINE_COMMENT
    PLUS_ASSIGN
    PRE_PROCESSOR
    QUESTION_MARK
    SHIFT_LEFT_ASSIGN
    SHIFT_RIGHT_ASSIGN
    TIMES_ASSIGN

Grammar

Rule 0     S' -> program
Rule 1     program -> function_declaration program
Rule 2     program -> function program
Rule 3     program -> <empty>
Rule 4     function_declaration -> signature SEMICOLON
Rule 5     command_block -> LBRACE commands RBRACE
Rule 6     command_block -> LBRACE RBRACE
Rule 7     commands -> command commands
Rule 8     commands -> command
Rule 9     command -> data_definition SEMICOLON
Rule 10    command -> while_loop
Rule 11    command -> assign SEMICOLON
Rule 12    command -> define_and_assign SEMICOLON
Rule 13    command -> expression SEMICOLON
Rule 14    command -> command_block
Rule 15    command -> SEMICOLON
Rule 16    command -> array_definition SEMICOLON
Rule 17    expression -> expression expression2
Rule 18    expression -> NOT expression
Rule 19    expression -> expression2
Rule 20    while_signature -> KEYWORD_WHILE LPAREN expression RPAREN
Rule 21    while_loop -> while_signature command_block
Rule 22    while_loop -> while_signature command
Rule 23    assign -> IDENTIFIER ASSIGN expression
Rule 24    define_and_assign -> type assign
Rule 25    define_and_assign -> pointer assign
Rule 26    expression2 -> LOGICAL_AND expression
Rule 27    expression2 -> LOGICAL_OR expression
Rule 28    expression2 -> PLUS expression
Rule 29    expression2 -> MINUS expression
Rule 30    expression2 -> TIMES expression
Rule 31    expression2 -> DIVIDE expression
Rule 32    expression2 -> MODULUS expression
Rule 33    expression2 -> EQUALS_THEN expression
Rule 34    expression2 -> NOT_EQUALS expression
Rule 35    expression2 -> GREATER_THEN expression
Rule 36    expression2 -> LESS_THEN expression
Rule 37    expression2 -> LESS_EQUALS expression
Rule 38    expression2 -> GREATER_EQUALS expression
Rule 39    expression2 -> LPAREN expression RPAREN
Rule 40    expression2 -> expression
Rule 41    expression2 -> IDENTIFIER
Rule 42    expression2 -> number
Rule 43    expression2 -> STRING
Rule 44    expression2 -> CHARACTER
Rule 45    expression2 -> assign
Rule 46    expression2 -> define_and_assign
Rule 47    number -> NUMBER
Rule 48    number -> FLOAT_NUMBER
Rule 49    number -> BINARY_NUMBER
Rule 50    number -> HEXADECIMAL_NUMBER
Rule 51    number -> OCTAL_NUMBER
Rule 52    function -> signature command_block
Rule 53    signature -> type IDENTIFIER function_parameters
Rule 54    signature -> pointer IDENTIFIER function_parameters
Rule 55    function_parameters -> LPAREN parameters_list RPAREN
Rule 56    function_parameters -> LPAREN RPAREN
Rule 57    parameters_list -> data_definition COMMA parameters_list
Rule 58    parameters_list -> data_definition
Rule 59    parameters_list -> array_definition COMMA parameters_list
Rule 60    parameters_list -> array_definition
Rule 61    parameters_list -> array_declaration COMMA parameters_list
Rule 62    parameters_list -> array_declaration
Rule 63    array_declaration -> type IDENTIFIER LBRACKET RBRACKET
Rule 64    array_declaration -> pointer IDENTIFIER LBRACKET RBRACKET
Rule 65    data_definition -> type IDENTIFIER
Rule 66    data_definition -> pointer IDENTIFIER
Rule 67    array_definition -> static_array_definition
Rule 68    array_definition -> runtime_array_definition
Rule 69    static_array_definition -> type IDENTIFIER LBRACKET NUMBER RBRACKET
Rule 70    static_array_definition -> pointer IDENTIFIER LBRACKET NUMBER RBRACKET
Rule 71    runtime_array_definition -> type IDENTIFIER LBRACKET IDENTIFIER RBRACKET
Rule 72    runtime_array_definition -> pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET
Rule 73    type -> primitive_types
Rule 74    type -> user_types
Rule 75    primitive_types -> TYPE_CHAR
Rule 76    primitive_types -> TYPE_DOUBLE
Rule 77    primitive_types -> TYPE_FLOAT
Rule 78    primitive_types -> TYPE_INT
Rule 79    primitive_types -> TYPE_LONG
Rule 80    primitive_types -> TYPE_SHORT
Rule 81    primitive_types -> TYPE_VOID
Rule 82    user_types -> IDENTIFIER
Rule 83    user_types -> KEYWORD_STRUCT IDENTIFIER
Rule 84    pointer -> type TIMES multiple_pointer
Rule 85    pointer -> type TIMES
Rule 86    multiple_pointer -> TIMES multiple_pointer
Rule 87    multiple_pointer -> TIMES

Terminals, with rules where they appear

ARROW                : 
ASSIGN               : 23
BINARY_NUMBER        : 49
BITWISE_AND          : 
BITWISE_AND_ASSIGN   : 
BITWISE_COMPLEMENT   : 
BITWISE_OR           : 
BITWISE_OR_ASSIGN    : 
BITWISE_SHIFT_LEFT   : 
BITWISE_SHIFT_RIGHT  : 
BITWISE_XOR          : 
BITWISE_XOR_ASSIGN   : 
CHARACTER            : 44
COLON                : 
COMMA                : 57 59 61
COMMENT              : 
DECREMENT            : 
DIVIDE               : 31
DIVIDE_ASSIGN        : 
DOT                  : 
EQUALS_THEN          : 33
FLOAT_NUMBER         : 48
GREATER_EQUALS       : 38
GREATER_THEN         : 35
HEXADECIMAL_NUMBER   : 50
IDENTIFIER           : 23 41 53 54 63 64 65 66 69 70 71 71 72 72 82 83
INCREMENT            : 
KEYWORD_AUTO         : 
KEYWORD_BREAK        : 
KEYWORD_CASE         : 
KEYWORD_CONST        : 
KEYWORD_CONTINUE     : 
KEYWORD_DEFAULT      : 
KEYWORD_DO           : 
KEYWORD_ELSE         : 
KEYWORD_ENUM         : 
KEYWORD_EXTERN       : 
KEYWORD_FOR          : 
KEYWORD_GOTO         : 
KEYWORD_IF           : 
KEYWORD_REGISTER     : 
KEYWORD_RETURN       : 
KEYWORD_SIGNED       : 
KEYWORD_SIZEOF       : 
KEYWORD_STATIC       : 
KEYWORD_STRUCT       : 83
KEYWORD_SWITCH       : 
KEYWORD_TYPEDEF      : 
KEYWORD_UNION        : 
KEYWORD_UNSIGNED     : 
KEYWORD_VOLATILE     : 
KEYWORD_WHILE        : 20
LBRACE               : 5 6
LBRACKET             : 63 64 69 70 71 72
LESS_EQUALS          : 37
LESS_THEN            : 36
LOGICAL_AND          : 26
LOGICAL_OR           : 27
LPAREN               : 20 39 55 56
MINUS                : 29
MINUS_ASSIGN         : 
MODULUS              : 32
MODULUS_ASSIGN       : 
MULTILINE_COMMENT    : 
NOT                  : 18
NOT_EQUALS           : 34
NUMBER               : 47 69 70
OCTAL_NUMBER         : 51
PLUS                 : 28
PLUS_ASSIGN          : 
PRE_PROCESSOR        : 
QUESTION_MARK        : 
RBRACE               : 5 6
RBRACKET             : 63 64 69 70 71 72
RPAREN               : 20 39 55 56
SEMICOLON            : 4 9 11 12 13 15 16
SHIFT_LEFT_ASSIGN    : 
SHIFT_RIGHT_ASSIGN   : 
STRING               : 43
TIMES                : 30 84 85 86 87
TIMES_ASSIGN         : 
TYPE_CHAR            : 75
TYPE_DOUBLE          : 76
TYPE_FLOAT           : 77
TYPE_INT             : 78
TYPE_LONG            : 79
TYPE_SHORT           : 80
TYPE_VOID            : 81
error                : 

Nonterminals, with rules where they appear

array_declaration    : 61 62
array_definition     : 16 59 60
assign               : 11 24 25 45
command              : 7 8 22
command_block        : 14 21 52
commands             : 5 7
data_definition      : 9 57 58
define_and_assign    : 12 46
expression           : 13 17 18 20 23 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40
expression2          : 17 19
function             : 2
function_declaration : 1
function_parameters  : 53 54
multiple_pointer     : 84 86
number               : 42
parameters_list      : 55 57 59 61
pointer              : 25 54 64 66 70 72
primitive_types      : 73
program              : 1 2 0
runtime_array_definition : 68
signature            : 4 52
static_array_definition : 67
type                 : 24 53 63 65 69 71 84 85
user_types           : 74
while_loop           : 10
while_signature      : 21 22

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . function_declaration program
    (2) program -> . function program
    (3) program -> .
    (4) function_declaration -> . signature SEMICOLON
    (52) function -> . signature command_block
    (53) signature -> . type IDENTIFIER function_parameters
    (54) signature -> . pointer IDENTIFIER function_parameters
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    $end            reduce using rule 3 (program -> .)
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    IDENTIFIER      shift and go to state 6
    KEYWORD_STRUCT  shift and go to state 17

    program                        shift and go to state 1
    function_declaration           shift and go to state 2
    function                       shift and go to state 3
    signature                      shift and go to state 4
    type                           shift and go to state 5
    pointer                        shift and go to state 7
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 1

    (0) S' -> program .



state 2

    (1) program -> function_declaration . program
    (1) program -> . function_declaration program
    (2) program -> . function program
    (3) program -> .
    (4) function_declaration -> . signature SEMICOLON
    (52) function -> . signature command_block
    (53) signature -> . type IDENTIFIER function_parameters
    (54) signature -> . pointer IDENTIFIER function_parameters
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    $end            reduce using rule 3 (program -> .)
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    IDENTIFIER      shift and go to state 6
    KEYWORD_STRUCT  shift and go to state 17

    function_declaration           shift and go to state 2
    program                        shift and go to state 18
    function                       shift and go to state 3
    signature                      shift and go to state 4
    type                           shift and go to state 5
    pointer                        shift and go to state 7
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 3

    (2) program -> function . program
    (1) program -> . function_declaration program
    (2) program -> . function program
    (3) program -> .
    (4) function_declaration -> . signature SEMICOLON
    (52) function -> . signature command_block
    (53) signature -> . type IDENTIFIER function_parameters
    (54) signature -> . pointer IDENTIFIER function_parameters
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    $end            reduce using rule 3 (program -> .)
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    IDENTIFIER      shift and go to state 6
    KEYWORD_STRUCT  shift and go to state 17

    function                       shift and go to state 3
    program                        shift and go to state 19
    function_declaration           shift and go to state 2
    signature                      shift and go to state 4
    type                           shift and go to state 5
    pointer                        shift and go to state 7
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 4

    (4) function_declaration -> signature . SEMICOLON
    (52) function -> signature . command_block
    (5) command_block -> . LBRACE commands RBRACE
    (6) command_block -> . LBRACE RBRACE

    SEMICOLON       shift and go to state 20
    LBRACE          shift and go to state 22

    command_block                  shift and go to state 21

state 5

    (53) signature -> type . IDENTIFIER function_parameters
    (84) pointer -> type . TIMES multiple_pointer
    (85) pointer -> type . TIMES

    IDENTIFIER      shift and go to state 23
    TIMES           shift and go to state 24


state 6

    (82) user_types -> IDENTIFIER .

    IDENTIFIER      reduce using rule 82 (user_types -> IDENTIFIER .)
    TIMES           reduce using rule 82 (user_types -> IDENTIFIER .)


state 7

    (54) signature -> pointer . IDENTIFIER function_parameters

    IDENTIFIER      shift and go to state 25


state 8

    (73) type -> primitive_types .

    IDENTIFIER      reduce using rule 73 (type -> primitive_types .)
    TIMES           reduce using rule 73 (type -> primitive_types .)


state 9

    (74) type -> user_types .

    IDENTIFIER      reduce using rule 74 (type -> user_types .)
    TIMES           reduce using rule 74 (type -> user_types .)


state 10

    (75) primitive_types -> TYPE_CHAR .

    IDENTIFIER      reduce using rule 75 (primitive_types -> TYPE_CHAR .)
    TIMES           reduce using rule 75 (primitive_types -> TYPE_CHAR .)


state 11

    (76) primitive_types -> TYPE_DOUBLE .

    IDENTIFIER      reduce using rule 76 (primitive_types -> TYPE_DOUBLE .)
    TIMES           reduce using rule 76 (primitive_types -> TYPE_DOUBLE .)


state 12

    (77) primitive_types -> TYPE_FLOAT .

    IDENTIFIER      reduce using rule 77 (primitive_types -> TYPE_FLOAT .)
    TIMES           reduce using rule 77 (primitive_types -> TYPE_FLOAT .)


state 13

    (78) primitive_types -> TYPE_INT .

    IDENTIFIER      reduce using rule 78 (primitive_types -> TYPE_INT .)
    TIMES           reduce using rule 78 (primitive_types -> TYPE_INT .)


state 14

    (79) primitive_types -> TYPE_LONG .

    IDENTIFIER      reduce using rule 79 (primitive_types -> TYPE_LONG .)
    TIMES           reduce using rule 79 (primitive_types -> TYPE_LONG .)


state 15

    (80) primitive_types -> TYPE_SHORT .

    IDENTIFIER      reduce using rule 80 (primitive_types -> TYPE_SHORT .)
    TIMES           reduce using rule 80 (primitive_types -> TYPE_SHORT .)


state 16

    (81) primitive_types -> TYPE_VOID .

    IDENTIFIER      reduce using rule 81 (primitive_types -> TYPE_VOID .)
    TIMES           reduce using rule 81 (primitive_types -> TYPE_VOID .)


state 17

    (83) user_types -> KEYWORD_STRUCT . IDENTIFIER

    IDENTIFIER      shift and go to state 26


state 18

    (1) program -> function_declaration program .

    $end            reduce using rule 1 (program -> function_declaration program .)


state 19

    (2) program -> function program .

    $end            reduce using rule 2 (program -> function program .)


state 20

    (4) function_declaration -> signature SEMICOLON .

    TYPE_CHAR       reduce using rule 4 (function_declaration -> signature SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 4 (function_declaration -> signature SEMICOLON .)
    TYPE_FLOAT      reduce using rule 4 (function_declaration -> signature SEMICOLON .)
    TYPE_INT        reduce using rule 4 (function_declaration -> signature SEMICOLON .)
    TYPE_LONG       reduce using rule 4 (function_declaration -> signature SEMICOLON .)
    TYPE_SHORT      reduce using rule 4 (function_declaration -> signature SEMICOLON .)
    TYPE_VOID       reduce using rule 4 (function_declaration -> signature SEMICOLON .)
    IDENTIFIER      reduce using rule 4 (function_declaration -> signature SEMICOLON .)
    KEYWORD_STRUCT  reduce using rule 4 (function_declaration -> signature SEMICOLON .)
    $end            reduce using rule 4 (function_declaration -> signature SEMICOLON .)


state 21

    (52) function -> signature command_block .

    TYPE_CHAR       reduce using rule 52 (function -> signature command_block .)
    TYPE_DOUBLE     reduce using rule 52 (function -> signature command_block .)
    TYPE_FLOAT      reduce using rule 52 (function -> signature command_block .)
    TYPE_INT        reduce using rule 52 (function -> signature command_block .)
    TYPE_LONG       reduce using rule 52 (function -> signature command_block .)
    TYPE_SHORT      reduce using rule 52 (function -> signature command_block .)
    TYPE_VOID       reduce using rule 52 (function -> signature command_block .)
    IDENTIFIER      reduce using rule 52 (function -> signature command_block .)
    KEYWORD_STRUCT  reduce using rule 52 (function -> signature command_block .)
    $end            reduce using rule 52 (function -> signature command_block .)


state 22

    (5) command_block -> LBRACE . commands RBRACE
    (6) command_block -> LBRACE . RBRACE
    (7) commands -> . command commands
    (8) commands -> . command
    (9) command -> . data_definition SEMICOLON
    (10) command -> . while_loop
    (11) command -> . assign SEMICOLON
    (12) command -> . define_and_assign SEMICOLON
    (13) command -> . expression SEMICOLON
    (14) command -> . command_block
    (15) command -> . SEMICOLON
    (16) command -> . array_definition SEMICOLON
    (65) data_definition -> . type IDENTIFIER
    (66) data_definition -> . pointer IDENTIFIER
    (21) while_loop -> . while_signature command_block
    (22) while_loop -> . while_signature command
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (5) command_block -> . LBRACE commands RBRACE
    (6) command_block -> . LBRACE RBRACE
    (67) array_definition -> . static_array_definition
    (68) array_definition -> . runtime_array_definition
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (20) while_signature -> . KEYWORD_WHILE LPAREN expression RPAREN
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (69) static_array_definition -> . type IDENTIFIER LBRACKET NUMBER RBRACKET
    (70) static_array_definition -> . pointer IDENTIFIER LBRACKET NUMBER RBRACKET
    (71) runtime_array_definition -> . type IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (72) runtime_array_definition -> . pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER

    RBRACE          shift and go to state 28
    SEMICOLON       shift and go to state 31
    IDENTIFIER      shift and go to state 39
    NOT             shift and go to state 43
    LBRACE          shift and go to state 22
    KEYWORD_WHILE   shift and go to state 47
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68

    commands                       shift and go to state 27
    command                        shift and go to state 29
    data_definition                shift and go to state 30
    while_loop                     shift and go to state 32
    assign                         shift and go to state 33
    define_and_assign              shift and go to state 34
    expression                     shift and go to state 35
    command_block                  shift and go to state 36
    array_definition               shift and go to state 37
    type                           shift and go to state 38
    pointer                        shift and go to state 40
    while_signature                shift and go to state 41
    expression2                    shift and go to state 42
    static_array_definition        shift and go to state 44
    runtime_array_definition       shift and go to state 45
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9
    number                         shift and go to state 61

state 23

    (53) signature -> type IDENTIFIER . function_parameters
    (55) function_parameters -> . LPAREN parameters_list RPAREN
    (56) function_parameters -> . LPAREN RPAREN

    LPAREN          shift and go to state 70

    function_parameters            shift and go to state 69

state 24

    (84) pointer -> type TIMES . multiple_pointer
    (85) pointer -> type TIMES .
    (86) multiple_pointer -> . TIMES multiple_pointer
    (87) multiple_pointer -> . TIMES

    IDENTIFIER      reduce using rule 85 (pointer -> type TIMES .)
    TIMES           shift and go to state 71

    multiple_pointer               shift and go to state 72

state 25

    (54) signature -> pointer IDENTIFIER . function_parameters
    (55) function_parameters -> . LPAREN parameters_list RPAREN
    (56) function_parameters -> . LPAREN RPAREN

    LPAREN          shift and go to state 70

    function_parameters            shift and go to state 73

state 26

    (83) user_types -> KEYWORD_STRUCT IDENTIFIER .

    IDENTIFIER      reduce using rule 83 (user_types -> KEYWORD_STRUCT IDENTIFIER .)
    TIMES           reduce using rule 83 (user_types -> KEYWORD_STRUCT IDENTIFIER .)


state 27

    (5) command_block -> LBRACE commands . RBRACE

    RBRACE          shift and go to state 74


state 28

    (6) command_block -> LBRACE RBRACE .

    TYPE_CHAR       reduce using rule 6 (command_block -> LBRACE RBRACE .)
    TYPE_DOUBLE     reduce using rule 6 (command_block -> LBRACE RBRACE .)
    TYPE_FLOAT      reduce using rule 6 (command_block -> LBRACE RBRACE .)
    TYPE_INT        reduce using rule 6 (command_block -> LBRACE RBRACE .)
    TYPE_LONG       reduce using rule 6 (command_block -> LBRACE RBRACE .)
    TYPE_SHORT      reduce using rule 6 (command_block -> LBRACE RBRACE .)
    TYPE_VOID       reduce using rule 6 (command_block -> LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 6 (command_block -> LBRACE RBRACE .)
    KEYWORD_STRUCT  reduce using rule 6 (command_block -> LBRACE RBRACE .)
    $end            reduce using rule 6 (command_block -> LBRACE RBRACE .)
    SEMICOLON       reduce using rule 6 (command_block -> LBRACE RBRACE .)
    NOT             reduce using rule 6 (command_block -> LBRACE RBRACE .)
    LBRACE          reduce using rule 6 (command_block -> LBRACE RBRACE .)
    KEYWORD_WHILE   reduce using rule 6 (command_block -> LBRACE RBRACE .)
    LOGICAL_AND     reduce using rule 6 (command_block -> LBRACE RBRACE .)
    LOGICAL_OR      reduce using rule 6 (command_block -> LBRACE RBRACE .)
    PLUS            reduce using rule 6 (command_block -> LBRACE RBRACE .)
    MINUS           reduce using rule 6 (command_block -> LBRACE RBRACE .)
    TIMES           reduce using rule 6 (command_block -> LBRACE RBRACE .)
    DIVIDE          reduce using rule 6 (command_block -> LBRACE RBRACE .)
    MODULUS         reduce using rule 6 (command_block -> LBRACE RBRACE .)
    EQUALS_THEN     reduce using rule 6 (command_block -> LBRACE RBRACE .)
    NOT_EQUALS      reduce using rule 6 (command_block -> LBRACE RBRACE .)
    GREATER_THEN    reduce using rule 6 (command_block -> LBRACE RBRACE .)
    LESS_THEN       reduce using rule 6 (command_block -> LBRACE RBRACE .)
    LESS_EQUALS     reduce using rule 6 (command_block -> LBRACE RBRACE .)
    GREATER_EQUALS  reduce using rule 6 (command_block -> LBRACE RBRACE .)
    LPAREN          reduce using rule 6 (command_block -> LBRACE RBRACE .)
    STRING          reduce using rule 6 (command_block -> LBRACE RBRACE .)
    CHARACTER       reduce using rule 6 (command_block -> LBRACE RBRACE .)
    NUMBER          reduce using rule 6 (command_block -> LBRACE RBRACE .)
    FLOAT_NUMBER    reduce using rule 6 (command_block -> LBRACE RBRACE .)
    BINARY_NUMBER   reduce using rule 6 (command_block -> LBRACE RBRACE .)
    HEXADECIMAL_NUMBER reduce using rule 6 (command_block -> LBRACE RBRACE .)
    OCTAL_NUMBER    reduce using rule 6 (command_block -> LBRACE RBRACE .)
    RBRACE          reduce using rule 6 (command_block -> LBRACE RBRACE .)


state 29

    (7) commands -> command . commands
    (8) commands -> command .
    (7) commands -> . command commands
    (8) commands -> . command
    (9) command -> . data_definition SEMICOLON
    (10) command -> . while_loop
    (11) command -> . assign SEMICOLON
    (12) command -> . define_and_assign SEMICOLON
    (13) command -> . expression SEMICOLON
    (14) command -> . command_block
    (15) command -> . SEMICOLON
    (16) command -> . array_definition SEMICOLON
    (65) data_definition -> . type IDENTIFIER
    (66) data_definition -> . pointer IDENTIFIER
    (21) while_loop -> . while_signature command_block
    (22) while_loop -> . while_signature command
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (5) command_block -> . LBRACE commands RBRACE
    (6) command_block -> . LBRACE RBRACE
    (67) array_definition -> . static_array_definition
    (68) array_definition -> . runtime_array_definition
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (20) while_signature -> . KEYWORD_WHILE LPAREN expression RPAREN
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (69) static_array_definition -> . type IDENTIFIER LBRACKET NUMBER RBRACKET
    (70) static_array_definition -> . pointer IDENTIFIER LBRACKET NUMBER RBRACKET
    (71) runtime_array_definition -> . type IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (72) runtime_array_definition -> . pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER

    RBRACE          reduce using rule 8 (commands -> command .)
    SEMICOLON       shift and go to state 31
    IDENTIFIER      shift and go to state 39
    NOT             shift and go to state 43
    LBRACE          shift and go to state 22
    KEYWORD_WHILE   shift and go to state 47
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68

    command                        shift and go to state 29
    commands                       shift and go to state 75
    data_definition                shift and go to state 30
    while_loop                     shift and go to state 32
    assign                         shift and go to state 33
    define_and_assign              shift and go to state 34
    expression                     shift and go to state 35
    command_block                  shift and go to state 36
    array_definition               shift and go to state 37
    type                           shift and go to state 38
    pointer                        shift and go to state 40
    while_signature                shift and go to state 41
    expression2                    shift and go to state 42
    static_array_definition        shift and go to state 44
    runtime_array_definition       shift and go to state 45
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9
    number                         shift and go to state 61

state 30

    (9) command -> data_definition . SEMICOLON

    SEMICOLON       shift and go to state 76


state 31

    (15) command -> SEMICOLON .

    SEMICOLON       reduce using rule 15 (command -> SEMICOLON .)
    IDENTIFIER      reduce using rule 15 (command -> SEMICOLON .)
    NOT             reduce using rule 15 (command -> SEMICOLON .)
    LBRACE          reduce using rule 15 (command -> SEMICOLON .)
    KEYWORD_WHILE   reduce using rule 15 (command -> SEMICOLON .)
    LOGICAL_AND     reduce using rule 15 (command -> SEMICOLON .)
    LOGICAL_OR      reduce using rule 15 (command -> SEMICOLON .)
    PLUS            reduce using rule 15 (command -> SEMICOLON .)
    MINUS           reduce using rule 15 (command -> SEMICOLON .)
    TIMES           reduce using rule 15 (command -> SEMICOLON .)
    DIVIDE          reduce using rule 15 (command -> SEMICOLON .)
    MODULUS         reduce using rule 15 (command -> SEMICOLON .)
    EQUALS_THEN     reduce using rule 15 (command -> SEMICOLON .)
    NOT_EQUALS      reduce using rule 15 (command -> SEMICOLON .)
    GREATER_THEN    reduce using rule 15 (command -> SEMICOLON .)
    LESS_THEN       reduce using rule 15 (command -> SEMICOLON .)
    LESS_EQUALS     reduce using rule 15 (command -> SEMICOLON .)
    GREATER_EQUALS  reduce using rule 15 (command -> SEMICOLON .)
    LPAREN          reduce using rule 15 (command -> SEMICOLON .)
    STRING          reduce using rule 15 (command -> SEMICOLON .)
    CHARACTER       reduce using rule 15 (command -> SEMICOLON .)
    TYPE_CHAR       reduce using rule 15 (command -> SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 15 (command -> SEMICOLON .)
    TYPE_FLOAT      reduce using rule 15 (command -> SEMICOLON .)
    TYPE_INT        reduce using rule 15 (command -> SEMICOLON .)
    TYPE_LONG       reduce using rule 15 (command -> SEMICOLON .)
    TYPE_SHORT      reduce using rule 15 (command -> SEMICOLON .)
    TYPE_VOID       reduce using rule 15 (command -> SEMICOLON .)
    KEYWORD_STRUCT  reduce using rule 15 (command -> SEMICOLON .)
    NUMBER          reduce using rule 15 (command -> SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 15 (command -> SEMICOLON .)
    BINARY_NUMBER   reduce using rule 15 (command -> SEMICOLON .)
    HEXADECIMAL_NUMBER reduce using rule 15 (command -> SEMICOLON .)
    OCTAL_NUMBER    reduce using rule 15 (command -> SEMICOLON .)
    RBRACE          reduce using rule 15 (command -> SEMICOLON .)


state 32

    (10) command -> while_loop .

    SEMICOLON       reduce using rule 10 (command -> while_loop .)
    IDENTIFIER      reduce using rule 10 (command -> while_loop .)
    NOT             reduce using rule 10 (command -> while_loop .)
    LBRACE          reduce using rule 10 (command -> while_loop .)
    KEYWORD_WHILE   reduce using rule 10 (command -> while_loop .)
    LOGICAL_AND     reduce using rule 10 (command -> while_loop .)
    LOGICAL_OR      reduce using rule 10 (command -> while_loop .)
    PLUS            reduce using rule 10 (command -> while_loop .)
    MINUS           reduce using rule 10 (command -> while_loop .)
    TIMES           reduce using rule 10 (command -> while_loop .)
    DIVIDE          reduce using rule 10 (command -> while_loop .)
    MODULUS         reduce using rule 10 (command -> while_loop .)
    EQUALS_THEN     reduce using rule 10 (command -> while_loop .)
    NOT_EQUALS      reduce using rule 10 (command -> while_loop .)
    GREATER_THEN    reduce using rule 10 (command -> while_loop .)
    LESS_THEN       reduce using rule 10 (command -> while_loop .)
    LESS_EQUALS     reduce using rule 10 (command -> while_loop .)
    GREATER_EQUALS  reduce using rule 10 (command -> while_loop .)
    LPAREN          reduce using rule 10 (command -> while_loop .)
    STRING          reduce using rule 10 (command -> while_loop .)
    CHARACTER       reduce using rule 10 (command -> while_loop .)
    TYPE_CHAR       reduce using rule 10 (command -> while_loop .)
    TYPE_DOUBLE     reduce using rule 10 (command -> while_loop .)
    TYPE_FLOAT      reduce using rule 10 (command -> while_loop .)
    TYPE_INT        reduce using rule 10 (command -> while_loop .)
    TYPE_LONG       reduce using rule 10 (command -> while_loop .)
    TYPE_SHORT      reduce using rule 10 (command -> while_loop .)
    TYPE_VOID       reduce using rule 10 (command -> while_loop .)
    KEYWORD_STRUCT  reduce using rule 10 (command -> while_loop .)
    NUMBER          reduce using rule 10 (command -> while_loop .)
    FLOAT_NUMBER    reduce using rule 10 (command -> while_loop .)
    BINARY_NUMBER   reduce using rule 10 (command -> while_loop .)
    HEXADECIMAL_NUMBER reduce using rule 10 (command -> while_loop .)
    OCTAL_NUMBER    reduce using rule 10 (command -> while_loop .)
    RBRACE          reduce using rule 10 (command -> while_loop .)


state 33

    (11) command -> assign . SEMICOLON
    (45) expression2 -> assign .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 77
    LOGICAL_AND     reduce using rule 45 (expression2 -> assign .)
    LOGICAL_OR      reduce using rule 45 (expression2 -> assign .)
    PLUS            reduce using rule 45 (expression2 -> assign .)
    MINUS           reduce using rule 45 (expression2 -> assign .)
    TIMES           reduce using rule 45 (expression2 -> assign .)
    DIVIDE          reduce using rule 45 (expression2 -> assign .)
    MODULUS         reduce using rule 45 (expression2 -> assign .)
    EQUALS_THEN     reduce using rule 45 (expression2 -> assign .)
    NOT_EQUALS      reduce using rule 45 (expression2 -> assign .)
    GREATER_THEN    reduce using rule 45 (expression2 -> assign .)
    LESS_THEN       reduce using rule 45 (expression2 -> assign .)
    LESS_EQUALS     reduce using rule 45 (expression2 -> assign .)
    GREATER_EQUALS  reduce using rule 45 (expression2 -> assign .)
    LPAREN          reduce using rule 45 (expression2 -> assign .)
    IDENTIFIER      reduce using rule 45 (expression2 -> assign .)
    STRING          reduce using rule 45 (expression2 -> assign .)
    CHARACTER       reduce using rule 45 (expression2 -> assign .)
    NOT             reduce using rule 45 (expression2 -> assign .)
    NUMBER          reduce using rule 45 (expression2 -> assign .)
    FLOAT_NUMBER    reduce using rule 45 (expression2 -> assign .)
    BINARY_NUMBER   reduce using rule 45 (expression2 -> assign .)
    HEXADECIMAL_NUMBER reduce using rule 45 (expression2 -> assign .)
    OCTAL_NUMBER    reduce using rule 45 (expression2 -> assign .)
    TYPE_CHAR       reduce using rule 45 (expression2 -> assign .)
    TYPE_DOUBLE     reduce using rule 45 (expression2 -> assign .)
    TYPE_FLOAT      reduce using rule 45 (expression2 -> assign .)
    TYPE_INT        reduce using rule 45 (expression2 -> assign .)
    TYPE_LONG       reduce using rule 45 (expression2 -> assign .)
    TYPE_SHORT      reduce using rule 45 (expression2 -> assign .)
    TYPE_VOID       reduce using rule 45 (expression2 -> assign .)
    KEYWORD_STRUCT  reduce using rule 45 (expression2 -> assign .)

  ! SEMICOLON       [ reduce using rule 45 (expression2 -> assign .) ]


state 34

    (12) command -> define_and_assign . SEMICOLON
    (46) expression2 -> define_and_assign .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 78
    LOGICAL_AND     reduce using rule 46 (expression2 -> define_and_assign .)
    LOGICAL_OR      reduce using rule 46 (expression2 -> define_and_assign .)
    PLUS            reduce using rule 46 (expression2 -> define_and_assign .)
    MINUS           reduce using rule 46 (expression2 -> define_and_assign .)
    TIMES           reduce using rule 46 (expression2 -> define_and_assign .)
    DIVIDE          reduce using rule 46 (expression2 -> define_and_assign .)
    MODULUS         reduce using rule 46 (expression2 -> define_and_assign .)
    EQUALS_THEN     reduce using rule 46 (expression2 -> define_and_assign .)
    NOT_EQUALS      reduce using rule 46 (expression2 -> define_and_assign .)
    GREATER_THEN    reduce using rule 46 (expression2 -> define_and_assign .)
    LESS_THEN       reduce using rule 46 (expression2 -> define_and_assign .)
    LESS_EQUALS     reduce using rule 46 (expression2 -> define_and_assign .)
    GREATER_EQUALS  reduce using rule 46 (expression2 -> define_and_assign .)
    LPAREN          reduce using rule 46 (expression2 -> define_and_assign .)
    IDENTIFIER      reduce using rule 46 (expression2 -> define_and_assign .)
    STRING          reduce using rule 46 (expression2 -> define_and_assign .)
    CHARACTER       reduce using rule 46 (expression2 -> define_and_assign .)
    NOT             reduce using rule 46 (expression2 -> define_and_assign .)
    NUMBER          reduce using rule 46 (expression2 -> define_and_assign .)
    FLOAT_NUMBER    reduce using rule 46 (expression2 -> define_and_assign .)
    BINARY_NUMBER   reduce using rule 46 (expression2 -> define_and_assign .)
    HEXADECIMAL_NUMBER reduce using rule 46 (expression2 -> define_and_assign .)
    OCTAL_NUMBER    reduce using rule 46 (expression2 -> define_and_assign .)
    TYPE_CHAR       reduce using rule 46 (expression2 -> define_and_assign .)
    TYPE_DOUBLE     reduce using rule 46 (expression2 -> define_and_assign .)
    TYPE_FLOAT      reduce using rule 46 (expression2 -> define_and_assign .)
    TYPE_INT        reduce using rule 46 (expression2 -> define_and_assign .)
    TYPE_LONG       reduce using rule 46 (expression2 -> define_and_assign .)
    TYPE_SHORT      reduce using rule 46 (expression2 -> define_and_assign .)
    TYPE_VOID       reduce using rule 46 (expression2 -> define_and_assign .)
    KEYWORD_STRUCT  reduce using rule 46 (expression2 -> define_and_assign .)

  ! SEMICOLON       [ reduce using rule 46 (expression2 -> define_and_assign .) ]


state 35

    (13) command -> expression . SEMICOLON
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       shift and go to state 80
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! SEMICOLON       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 36

    (14) command -> command_block .

    SEMICOLON       reduce using rule 14 (command -> command_block .)
    IDENTIFIER      reduce using rule 14 (command -> command_block .)
    NOT             reduce using rule 14 (command -> command_block .)
    LBRACE          reduce using rule 14 (command -> command_block .)
    KEYWORD_WHILE   reduce using rule 14 (command -> command_block .)
    LOGICAL_AND     reduce using rule 14 (command -> command_block .)
    LOGICAL_OR      reduce using rule 14 (command -> command_block .)
    PLUS            reduce using rule 14 (command -> command_block .)
    MINUS           reduce using rule 14 (command -> command_block .)
    TIMES           reduce using rule 14 (command -> command_block .)
    DIVIDE          reduce using rule 14 (command -> command_block .)
    MODULUS         reduce using rule 14 (command -> command_block .)
    EQUALS_THEN     reduce using rule 14 (command -> command_block .)
    NOT_EQUALS      reduce using rule 14 (command -> command_block .)
    GREATER_THEN    reduce using rule 14 (command -> command_block .)
    LESS_THEN       reduce using rule 14 (command -> command_block .)
    LESS_EQUALS     reduce using rule 14 (command -> command_block .)
    GREATER_EQUALS  reduce using rule 14 (command -> command_block .)
    LPAREN          reduce using rule 14 (command -> command_block .)
    STRING          reduce using rule 14 (command -> command_block .)
    CHARACTER       reduce using rule 14 (command -> command_block .)
    TYPE_CHAR       reduce using rule 14 (command -> command_block .)
    TYPE_DOUBLE     reduce using rule 14 (command -> command_block .)
    TYPE_FLOAT      reduce using rule 14 (command -> command_block .)
    TYPE_INT        reduce using rule 14 (command -> command_block .)
    TYPE_LONG       reduce using rule 14 (command -> command_block .)
    TYPE_SHORT      reduce using rule 14 (command -> command_block .)
    TYPE_VOID       reduce using rule 14 (command -> command_block .)
    KEYWORD_STRUCT  reduce using rule 14 (command -> command_block .)
    NUMBER          reduce using rule 14 (command -> command_block .)
    FLOAT_NUMBER    reduce using rule 14 (command -> command_block .)
    BINARY_NUMBER   reduce using rule 14 (command -> command_block .)
    HEXADECIMAL_NUMBER reduce using rule 14 (command -> command_block .)
    OCTAL_NUMBER    reduce using rule 14 (command -> command_block .)
    RBRACE          reduce using rule 14 (command -> command_block .)


state 37

    (16) command -> array_definition . SEMICOLON

    SEMICOLON       shift and go to state 87


state 38

    (65) data_definition -> type . IDENTIFIER
    (24) define_and_assign -> type . assign
    (84) pointer -> type . TIMES multiple_pointer
    (85) pointer -> type . TIMES
    (69) static_array_definition -> type . IDENTIFIER LBRACKET NUMBER RBRACKET
    (71) runtime_array_definition -> type . IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (23) assign -> . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 88
    TIMES           shift and go to state 24

    assign                         shift and go to state 89

state 39

    (23) assign -> IDENTIFIER . ASSIGN expression
    (41) expression2 -> IDENTIFIER .
    (82) user_types -> IDENTIFIER .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 41 (expression2 -> IDENTIFIER .)
  ! reduce/reduce conflict for TIMES resolved using rule 41 (expression2 -> IDENTIFIER .)
    ASSIGN          shift and go to state 90
    SEMICOLON       reduce using rule 41 (expression2 -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 41 (expression2 -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 41 (expression2 -> IDENTIFIER .)
    PLUS            reduce using rule 41 (expression2 -> IDENTIFIER .)
    MINUS           reduce using rule 41 (expression2 -> IDENTIFIER .)
    TIMES           reduce using rule 41 (expression2 -> IDENTIFIER .)
    DIVIDE          reduce using rule 41 (expression2 -> IDENTIFIER .)
    MODULUS         reduce using rule 41 (expression2 -> IDENTIFIER .)
    EQUALS_THEN     reduce using rule 41 (expression2 -> IDENTIFIER .)
    NOT_EQUALS      reduce using rule 41 (expression2 -> IDENTIFIER .)
    GREATER_THEN    reduce using rule 41 (expression2 -> IDENTIFIER .)
    LESS_THEN       reduce using rule 41 (expression2 -> IDENTIFIER .)
    LESS_EQUALS     reduce using rule 41 (expression2 -> IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 41 (expression2 -> IDENTIFIER .)
    LPAREN          reduce using rule 41 (expression2 -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 41 (expression2 -> IDENTIFIER .)
    STRING          reduce using rule 41 (expression2 -> IDENTIFIER .)
    CHARACTER       reduce using rule 41 (expression2 -> IDENTIFIER .)
    NOT             reduce using rule 41 (expression2 -> IDENTIFIER .)
    NUMBER          reduce using rule 41 (expression2 -> IDENTIFIER .)
    FLOAT_NUMBER    reduce using rule 41 (expression2 -> IDENTIFIER .)
    BINARY_NUMBER   reduce using rule 41 (expression2 -> IDENTIFIER .)
    HEXADECIMAL_NUMBER reduce using rule 41 (expression2 -> IDENTIFIER .)
    OCTAL_NUMBER    reduce using rule 41 (expression2 -> IDENTIFIER .)
    TYPE_CHAR       reduce using rule 41 (expression2 -> IDENTIFIER .)
    TYPE_DOUBLE     reduce using rule 41 (expression2 -> IDENTIFIER .)
    TYPE_FLOAT      reduce using rule 41 (expression2 -> IDENTIFIER .)
    TYPE_INT        reduce using rule 41 (expression2 -> IDENTIFIER .)
    TYPE_LONG       reduce using rule 41 (expression2 -> IDENTIFIER .)
    TYPE_SHORT      reduce using rule 41 (expression2 -> IDENTIFIER .)
    TYPE_VOID       reduce using rule 41 (expression2 -> IDENTIFIER .)
    KEYWORD_STRUCT  reduce using rule 41 (expression2 -> IDENTIFIER .)

  ! IDENTIFIER      [ reduce using rule 82 (user_types -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 82 (user_types -> IDENTIFIER .) ]


state 40

    (66) data_definition -> pointer . IDENTIFIER
    (25) define_and_assign -> pointer . assign
    (70) static_array_definition -> pointer . IDENTIFIER LBRACKET NUMBER RBRACKET
    (72) runtime_array_definition -> pointer . IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (23) assign -> . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 91

    assign                         shift and go to state 92

state 41

    (21) while_loop -> while_signature . command_block
    (22) while_loop -> while_signature . command
    (5) command_block -> . LBRACE commands RBRACE
    (6) command_block -> . LBRACE RBRACE
    (9) command -> . data_definition SEMICOLON
    (10) command -> . while_loop
    (11) command -> . assign SEMICOLON
    (12) command -> . define_and_assign SEMICOLON
    (13) command -> . expression SEMICOLON
    (14) command -> . command_block
    (15) command -> . SEMICOLON
    (16) command -> . array_definition SEMICOLON
    (65) data_definition -> . type IDENTIFIER
    (66) data_definition -> . pointer IDENTIFIER
    (21) while_loop -> . while_signature command_block
    (22) while_loop -> . while_signature command
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (67) array_definition -> . static_array_definition
    (68) array_definition -> . runtime_array_definition
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (20) while_signature -> . KEYWORD_WHILE LPAREN expression RPAREN
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (69) static_array_definition -> . type IDENTIFIER LBRACKET NUMBER RBRACKET
    (70) static_array_definition -> . pointer IDENTIFIER LBRACKET NUMBER RBRACKET
    (71) runtime_array_definition -> . type IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (72) runtime_array_definition -> . pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER

    LBRACE          shift and go to state 22
    SEMICOLON       shift and go to state 31
    IDENTIFIER      shift and go to state 39
    NOT             shift and go to state 43
    KEYWORD_WHILE   shift and go to state 47
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68

    while_signature                shift and go to state 41
    command_block                  shift and go to state 93
    command                        shift and go to state 94
    data_definition                shift and go to state 30
    while_loop                     shift and go to state 32
    assign                         shift and go to state 33
    define_and_assign              shift and go to state 34
    expression                     shift and go to state 35
    array_definition               shift and go to state 37
    type                           shift and go to state 38
    pointer                        shift and go to state 40
    expression2                    shift and go to state 42
    static_array_definition        shift and go to state 44
    runtime_array_definition       shift and go to state 45
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9
    number                         shift and go to state 61

state 42

    (19) expression -> expression2 .

    SEMICOLON       reduce using rule 19 (expression -> expression2 .)
    LOGICAL_AND     reduce using rule 19 (expression -> expression2 .)
    LOGICAL_OR      reduce using rule 19 (expression -> expression2 .)
    PLUS            reduce using rule 19 (expression -> expression2 .)
    MINUS           reduce using rule 19 (expression -> expression2 .)
    TIMES           reduce using rule 19 (expression -> expression2 .)
    DIVIDE          reduce using rule 19 (expression -> expression2 .)
    MODULUS         reduce using rule 19 (expression -> expression2 .)
    EQUALS_THEN     reduce using rule 19 (expression -> expression2 .)
    NOT_EQUALS      reduce using rule 19 (expression -> expression2 .)
    GREATER_THEN    reduce using rule 19 (expression -> expression2 .)
    LESS_THEN       reduce using rule 19 (expression -> expression2 .)
    LESS_EQUALS     reduce using rule 19 (expression -> expression2 .)
    GREATER_EQUALS  reduce using rule 19 (expression -> expression2 .)
    LPAREN          reduce using rule 19 (expression -> expression2 .)
    IDENTIFIER      reduce using rule 19 (expression -> expression2 .)
    STRING          reduce using rule 19 (expression -> expression2 .)
    CHARACTER       reduce using rule 19 (expression -> expression2 .)
    NOT             reduce using rule 19 (expression -> expression2 .)
    NUMBER          reduce using rule 19 (expression -> expression2 .)
    FLOAT_NUMBER    reduce using rule 19 (expression -> expression2 .)
    BINARY_NUMBER   reduce using rule 19 (expression -> expression2 .)
    HEXADECIMAL_NUMBER reduce using rule 19 (expression -> expression2 .)
    OCTAL_NUMBER    reduce using rule 19 (expression -> expression2 .)
    TYPE_CHAR       reduce using rule 19 (expression -> expression2 .)
    TYPE_DOUBLE     reduce using rule 19 (expression -> expression2 .)
    TYPE_FLOAT      reduce using rule 19 (expression -> expression2 .)
    TYPE_INT        reduce using rule 19 (expression -> expression2 .)
    TYPE_LONG       reduce using rule 19 (expression -> expression2 .)
    TYPE_SHORT      reduce using rule 19 (expression -> expression2 .)
    TYPE_VOID       reduce using rule 19 (expression -> expression2 .)
    KEYWORD_STRUCT  reduce using rule 19 (expression -> expression2 .)
    RPAREN          reduce using rule 19 (expression -> expression2 .)


state 43

    (18) expression -> NOT . expression
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 95
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 44

    (67) array_definition -> static_array_definition .

    SEMICOLON       reduce using rule 67 (array_definition -> static_array_definition .)
    COMMA           reduce using rule 67 (array_definition -> static_array_definition .)
    RPAREN          reduce using rule 67 (array_definition -> static_array_definition .)


state 45

    (68) array_definition -> runtime_array_definition .

    SEMICOLON       reduce using rule 68 (array_definition -> runtime_array_definition .)
    COMMA           reduce using rule 68 (array_definition -> runtime_array_definition .)
    RPAREN          reduce using rule 68 (array_definition -> runtime_array_definition .)


state 46

    (30) expression2 -> TIMES . expression
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 96
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 47

    (20) while_signature -> KEYWORD_WHILE . LPAREN expression RPAREN

    LPAREN          shift and go to state 97


state 48

    (39) expression2 -> LPAREN . expression RPAREN
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 98
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 49

    (26) expression2 -> LOGICAL_AND . expression
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 99
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 50

    (27) expression2 -> LOGICAL_OR . expression
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 100
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 51

    (28) expression2 -> PLUS . expression
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 101
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 52

    (29) expression2 -> MINUS . expression
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 102
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 53

    (31) expression2 -> DIVIDE . expression
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 103
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 54

    (32) expression2 -> MODULUS . expression
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 104
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 55

    (33) expression2 -> EQUALS_THEN . expression
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 105
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 56

    (34) expression2 -> NOT_EQUALS . expression
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 106
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 57

    (35) expression2 -> GREATER_THEN . expression
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 107
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 58

    (36) expression2 -> LESS_THEN . expression
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 108
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 59

    (37) expression2 -> LESS_EQUALS . expression
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 109
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 60

    (38) expression2 -> GREATER_EQUALS . expression
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 110
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 61

    (42) expression2 -> number .

    SEMICOLON       reduce using rule 42 (expression2 -> number .)
    LOGICAL_AND     reduce using rule 42 (expression2 -> number .)
    LOGICAL_OR      reduce using rule 42 (expression2 -> number .)
    PLUS            reduce using rule 42 (expression2 -> number .)
    MINUS           reduce using rule 42 (expression2 -> number .)
    TIMES           reduce using rule 42 (expression2 -> number .)
    DIVIDE          reduce using rule 42 (expression2 -> number .)
    MODULUS         reduce using rule 42 (expression2 -> number .)
    EQUALS_THEN     reduce using rule 42 (expression2 -> number .)
    NOT_EQUALS      reduce using rule 42 (expression2 -> number .)
    GREATER_THEN    reduce using rule 42 (expression2 -> number .)
    LESS_THEN       reduce using rule 42 (expression2 -> number .)
    LESS_EQUALS     reduce using rule 42 (expression2 -> number .)
    GREATER_EQUALS  reduce using rule 42 (expression2 -> number .)
    LPAREN          reduce using rule 42 (expression2 -> number .)
    IDENTIFIER      reduce using rule 42 (expression2 -> number .)
    STRING          reduce using rule 42 (expression2 -> number .)
    CHARACTER       reduce using rule 42 (expression2 -> number .)
    NOT             reduce using rule 42 (expression2 -> number .)
    NUMBER          reduce using rule 42 (expression2 -> number .)
    FLOAT_NUMBER    reduce using rule 42 (expression2 -> number .)
    BINARY_NUMBER   reduce using rule 42 (expression2 -> number .)
    HEXADECIMAL_NUMBER reduce using rule 42 (expression2 -> number .)
    OCTAL_NUMBER    reduce using rule 42 (expression2 -> number .)
    TYPE_CHAR       reduce using rule 42 (expression2 -> number .)
    TYPE_DOUBLE     reduce using rule 42 (expression2 -> number .)
    TYPE_FLOAT      reduce using rule 42 (expression2 -> number .)
    TYPE_INT        reduce using rule 42 (expression2 -> number .)
    TYPE_LONG       reduce using rule 42 (expression2 -> number .)
    TYPE_SHORT      reduce using rule 42 (expression2 -> number .)
    TYPE_VOID       reduce using rule 42 (expression2 -> number .)
    KEYWORD_STRUCT  reduce using rule 42 (expression2 -> number .)
    RPAREN          reduce using rule 42 (expression2 -> number .)


state 62

    (43) expression2 -> STRING .

    SEMICOLON       reduce using rule 43 (expression2 -> STRING .)
    LOGICAL_AND     reduce using rule 43 (expression2 -> STRING .)
    LOGICAL_OR      reduce using rule 43 (expression2 -> STRING .)
    PLUS            reduce using rule 43 (expression2 -> STRING .)
    MINUS           reduce using rule 43 (expression2 -> STRING .)
    TIMES           reduce using rule 43 (expression2 -> STRING .)
    DIVIDE          reduce using rule 43 (expression2 -> STRING .)
    MODULUS         reduce using rule 43 (expression2 -> STRING .)
    EQUALS_THEN     reduce using rule 43 (expression2 -> STRING .)
    NOT_EQUALS      reduce using rule 43 (expression2 -> STRING .)
    GREATER_THEN    reduce using rule 43 (expression2 -> STRING .)
    LESS_THEN       reduce using rule 43 (expression2 -> STRING .)
    LESS_EQUALS     reduce using rule 43 (expression2 -> STRING .)
    GREATER_EQUALS  reduce using rule 43 (expression2 -> STRING .)
    LPAREN          reduce using rule 43 (expression2 -> STRING .)
    IDENTIFIER      reduce using rule 43 (expression2 -> STRING .)
    STRING          reduce using rule 43 (expression2 -> STRING .)
    CHARACTER       reduce using rule 43 (expression2 -> STRING .)
    NOT             reduce using rule 43 (expression2 -> STRING .)
    NUMBER          reduce using rule 43 (expression2 -> STRING .)
    FLOAT_NUMBER    reduce using rule 43 (expression2 -> STRING .)
    BINARY_NUMBER   reduce using rule 43 (expression2 -> STRING .)
    HEXADECIMAL_NUMBER reduce using rule 43 (expression2 -> STRING .)
    OCTAL_NUMBER    reduce using rule 43 (expression2 -> STRING .)
    TYPE_CHAR       reduce using rule 43 (expression2 -> STRING .)
    TYPE_DOUBLE     reduce using rule 43 (expression2 -> STRING .)
    TYPE_FLOAT      reduce using rule 43 (expression2 -> STRING .)
    TYPE_INT        reduce using rule 43 (expression2 -> STRING .)
    TYPE_LONG       reduce using rule 43 (expression2 -> STRING .)
    TYPE_SHORT      reduce using rule 43 (expression2 -> STRING .)
    TYPE_VOID       reduce using rule 43 (expression2 -> STRING .)
    KEYWORD_STRUCT  reduce using rule 43 (expression2 -> STRING .)
    RPAREN          reduce using rule 43 (expression2 -> STRING .)


state 63

    (44) expression2 -> CHARACTER .

    SEMICOLON       reduce using rule 44 (expression2 -> CHARACTER .)
    LOGICAL_AND     reduce using rule 44 (expression2 -> CHARACTER .)
    LOGICAL_OR      reduce using rule 44 (expression2 -> CHARACTER .)
    PLUS            reduce using rule 44 (expression2 -> CHARACTER .)
    MINUS           reduce using rule 44 (expression2 -> CHARACTER .)
    TIMES           reduce using rule 44 (expression2 -> CHARACTER .)
    DIVIDE          reduce using rule 44 (expression2 -> CHARACTER .)
    MODULUS         reduce using rule 44 (expression2 -> CHARACTER .)
    EQUALS_THEN     reduce using rule 44 (expression2 -> CHARACTER .)
    NOT_EQUALS      reduce using rule 44 (expression2 -> CHARACTER .)
    GREATER_THEN    reduce using rule 44 (expression2 -> CHARACTER .)
    LESS_THEN       reduce using rule 44 (expression2 -> CHARACTER .)
    LESS_EQUALS     reduce using rule 44 (expression2 -> CHARACTER .)
    GREATER_EQUALS  reduce using rule 44 (expression2 -> CHARACTER .)
    LPAREN          reduce using rule 44 (expression2 -> CHARACTER .)
    IDENTIFIER      reduce using rule 44 (expression2 -> CHARACTER .)
    STRING          reduce using rule 44 (expression2 -> CHARACTER .)
    CHARACTER       reduce using rule 44 (expression2 -> CHARACTER .)
    NOT             reduce using rule 44 (expression2 -> CHARACTER .)
    NUMBER          reduce using rule 44 (expression2 -> CHARACTER .)
    FLOAT_NUMBER    reduce using rule 44 (expression2 -> CHARACTER .)
    BINARY_NUMBER   reduce using rule 44 (expression2 -> CHARACTER .)
    HEXADECIMAL_NUMBER reduce using rule 44 (expression2 -> CHARACTER .)
    OCTAL_NUMBER    reduce using rule 44 (expression2 -> CHARACTER .)
    TYPE_CHAR       reduce using rule 44 (expression2 -> CHARACTER .)
    TYPE_DOUBLE     reduce using rule 44 (expression2 -> CHARACTER .)
    TYPE_FLOAT      reduce using rule 44 (expression2 -> CHARACTER .)
    TYPE_INT        reduce using rule 44 (expression2 -> CHARACTER .)
    TYPE_LONG       reduce using rule 44 (expression2 -> CHARACTER .)
    TYPE_SHORT      reduce using rule 44 (expression2 -> CHARACTER .)
    TYPE_VOID       reduce using rule 44 (expression2 -> CHARACTER .)
    KEYWORD_STRUCT  reduce using rule 44 (expression2 -> CHARACTER .)
    RPAREN          reduce using rule 44 (expression2 -> CHARACTER .)


state 64

    (47) number -> NUMBER .

    SEMICOLON       reduce using rule 47 (number -> NUMBER .)
    LOGICAL_AND     reduce using rule 47 (number -> NUMBER .)
    LOGICAL_OR      reduce using rule 47 (number -> NUMBER .)
    PLUS            reduce using rule 47 (number -> NUMBER .)
    MINUS           reduce using rule 47 (number -> NUMBER .)
    TIMES           reduce using rule 47 (number -> NUMBER .)
    DIVIDE          reduce using rule 47 (number -> NUMBER .)
    MODULUS         reduce using rule 47 (number -> NUMBER .)
    EQUALS_THEN     reduce using rule 47 (number -> NUMBER .)
    NOT_EQUALS      reduce using rule 47 (number -> NUMBER .)
    GREATER_THEN    reduce using rule 47 (number -> NUMBER .)
    LESS_THEN       reduce using rule 47 (number -> NUMBER .)
    LESS_EQUALS     reduce using rule 47 (number -> NUMBER .)
    GREATER_EQUALS  reduce using rule 47 (number -> NUMBER .)
    LPAREN          reduce using rule 47 (number -> NUMBER .)
    IDENTIFIER      reduce using rule 47 (number -> NUMBER .)
    STRING          reduce using rule 47 (number -> NUMBER .)
    CHARACTER       reduce using rule 47 (number -> NUMBER .)
    NOT             reduce using rule 47 (number -> NUMBER .)
    NUMBER          reduce using rule 47 (number -> NUMBER .)
    FLOAT_NUMBER    reduce using rule 47 (number -> NUMBER .)
    BINARY_NUMBER   reduce using rule 47 (number -> NUMBER .)
    HEXADECIMAL_NUMBER reduce using rule 47 (number -> NUMBER .)
    OCTAL_NUMBER    reduce using rule 47 (number -> NUMBER .)
    TYPE_CHAR       reduce using rule 47 (number -> NUMBER .)
    TYPE_DOUBLE     reduce using rule 47 (number -> NUMBER .)
    TYPE_FLOAT      reduce using rule 47 (number -> NUMBER .)
    TYPE_INT        reduce using rule 47 (number -> NUMBER .)
    TYPE_LONG       reduce using rule 47 (number -> NUMBER .)
    TYPE_SHORT      reduce using rule 47 (number -> NUMBER .)
    TYPE_VOID       reduce using rule 47 (number -> NUMBER .)
    KEYWORD_STRUCT  reduce using rule 47 (number -> NUMBER .)
    RPAREN          reduce using rule 47 (number -> NUMBER .)


state 65

    (48) number -> FLOAT_NUMBER .

    SEMICOLON       reduce using rule 48 (number -> FLOAT_NUMBER .)
    LOGICAL_AND     reduce using rule 48 (number -> FLOAT_NUMBER .)
    LOGICAL_OR      reduce using rule 48 (number -> FLOAT_NUMBER .)
    PLUS            reduce using rule 48 (number -> FLOAT_NUMBER .)
    MINUS           reduce using rule 48 (number -> FLOAT_NUMBER .)
    TIMES           reduce using rule 48 (number -> FLOAT_NUMBER .)
    DIVIDE          reduce using rule 48 (number -> FLOAT_NUMBER .)
    MODULUS         reduce using rule 48 (number -> FLOAT_NUMBER .)
    EQUALS_THEN     reduce using rule 48 (number -> FLOAT_NUMBER .)
    NOT_EQUALS      reduce using rule 48 (number -> FLOAT_NUMBER .)
    GREATER_THEN    reduce using rule 48 (number -> FLOAT_NUMBER .)
    LESS_THEN       reduce using rule 48 (number -> FLOAT_NUMBER .)
    LESS_EQUALS     reduce using rule 48 (number -> FLOAT_NUMBER .)
    GREATER_EQUALS  reduce using rule 48 (number -> FLOAT_NUMBER .)
    LPAREN          reduce using rule 48 (number -> FLOAT_NUMBER .)
    IDENTIFIER      reduce using rule 48 (number -> FLOAT_NUMBER .)
    STRING          reduce using rule 48 (number -> FLOAT_NUMBER .)
    CHARACTER       reduce using rule 48 (number -> FLOAT_NUMBER .)
    NOT             reduce using rule 48 (number -> FLOAT_NUMBER .)
    NUMBER          reduce using rule 48 (number -> FLOAT_NUMBER .)
    FLOAT_NUMBER    reduce using rule 48 (number -> FLOAT_NUMBER .)
    BINARY_NUMBER   reduce using rule 48 (number -> FLOAT_NUMBER .)
    HEXADECIMAL_NUMBER reduce using rule 48 (number -> FLOAT_NUMBER .)
    OCTAL_NUMBER    reduce using rule 48 (number -> FLOAT_NUMBER .)
    TYPE_CHAR       reduce using rule 48 (number -> FLOAT_NUMBER .)
    TYPE_DOUBLE     reduce using rule 48 (number -> FLOAT_NUMBER .)
    TYPE_FLOAT      reduce using rule 48 (number -> FLOAT_NUMBER .)
    TYPE_INT        reduce using rule 48 (number -> FLOAT_NUMBER .)
    TYPE_LONG       reduce using rule 48 (number -> FLOAT_NUMBER .)
    TYPE_SHORT      reduce using rule 48 (number -> FLOAT_NUMBER .)
    TYPE_VOID       reduce using rule 48 (number -> FLOAT_NUMBER .)
    KEYWORD_STRUCT  reduce using rule 48 (number -> FLOAT_NUMBER .)
    RPAREN          reduce using rule 48 (number -> FLOAT_NUMBER .)


state 66

    (49) number -> BINARY_NUMBER .

    SEMICOLON       reduce using rule 49 (number -> BINARY_NUMBER .)
    LOGICAL_AND     reduce using rule 49 (number -> BINARY_NUMBER .)
    LOGICAL_OR      reduce using rule 49 (number -> BINARY_NUMBER .)
    PLUS            reduce using rule 49 (number -> BINARY_NUMBER .)
    MINUS           reduce using rule 49 (number -> BINARY_NUMBER .)
    TIMES           reduce using rule 49 (number -> BINARY_NUMBER .)
    DIVIDE          reduce using rule 49 (number -> BINARY_NUMBER .)
    MODULUS         reduce using rule 49 (number -> BINARY_NUMBER .)
    EQUALS_THEN     reduce using rule 49 (number -> BINARY_NUMBER .)
    NOT_EQUALS      reduce using rule 49 (number -> BINARY_NUMBER .)
    GREATER_THEN    reduce using rule 49 (number -> BINARY_NUMBER .)
    LESS_THEN       reduce using rule 49 (number -> BINARY_NUMBER .)
    LESS_EQUALS     reduce using rule 49 (number -> BINARY_NUMBER .)
    GREATER_EQUALS  reduce using rule 49 (number -> BINARY_NUMBER .)
    LPAREN          reduce using rule 49 (number -> BINARY_NUMBER .)
    IDENTIFIER      reduce using rule 49 (number -> BINARY_NUMBER .)
    STRING          reduce using rule 49 (number -> BINARY_NUMBER .)
    CHARACTER       reduce using rule 49 (number -> BINARY_NUMBER .)
    NOT             reduce using rule 49 (number -> BINARY_NUMBER .)
    NUMBER          reduce using rule 49 (number -> BINARY_NUMBER .)
    FLOAT_NUMBER    reduce using rule 49 (number -> BINARY_NUMBER .)
    BINARY_NUMBER   reduce using rule 49 (number -> BINARY_NUMBER .)
    HEXADECIMAL_NUMBER reduce using rule 49 (number -> BINARY_NUMBER .)
    OCTAL_NUMBER    reduce using rule 49 (number -> BINARY_NUMBER .)
    TYPE_CHAR       reduce using rule 49 (number -> BINARY_NUMBER .)
    TYPE_DOUBLE     reduce using rule 49 (number -> BINARY_NUMBER .)
    TYPE_FLOAT      reduce using rule 49 (number -> BINARY_NUMBER .)
    TYPE_INT        reduce using rule 49 (number -> BINARY_NUMBER .)
    TYPE_LONG       reduce using rule 49 (number -> BINARY_NUMBER .)
    TYPE_SHORT      reduce using rule 49 (number -> BINARY_NUMBER .)
    TYPE_VOID       reduce using rule 49 (number -> BINARY_NUMBER .)
    KEYWORD_STRUCT  reduce using rule 49 (number -> BINARY_NUMBER .)
    RPAREN          reduce using rule 49 (number -> BINARY_NUMBER .)


state 67

    (50) number -> HEXADECIMAL_NUMBER .

    SEMICOLON       reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    LOGICAL_AND     reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    LOGICAL_OR      reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    PLUS            reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    MINUS           reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    TIMES           reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    DIVIDE          reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    MODULUS         reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    EQUALS_THEN     reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    NOT_EQUALS      reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    GREATER_THEN    reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    LESS_THEN       reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    LESS_EQUALS     reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    GREATER_EQUALS  reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    LPAREN          reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    IDENTIFIER      reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    STRING          reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    CHARACTER       reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    NOT             reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    NUMBER          reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    FLOAT_NUMBER    reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    BINARY_NUMBER   reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    HEXADECIMAL_NUMBER reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    OCTAL_NUMBER    reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    TYPE_CHAR       reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    TYPE_DOUBLE     reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    TYPE_FLOAT      reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    TYPE_INT        reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    TYPE_LONG       reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    TYPE_SHORT      reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    TYPE_VOID       reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    KEYWORD_STRUCT  reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)
    RPAREN          reduce using rule 50 (number -> HEXADECIMAL_NUMBER .)


state 68

    (51) number -> OCTAL_NUMBER .

    SEMICOLON       reduce using rule 51 (number -> OCTAL_NUMBER .)
    LOGICAL_AND     reduce using rule 51 (number -> OCTAL_NUMBER .)
    LOGICAL_OR      reduce using rule 51 (number -> OCTAL_NUMBER .)
    PLUS            reduce using rule 51 (number -> OCTAL_NUMBER .)
    MINUS           reduce using rule 51 (number -> OCTAL_NUMBER .)
    TIMES           reduce using rule 51 (number -> OCTAL_NUMBER .)
    DIVIDE          reduce using rule 51 (number -> OCTAL_NUMBER .)
    MODULUS         reduce using rule 51 (number -> OCTAL_NUMBER .)
    EQUALS_THEN     reduce using rule 51 (number -> OCTAL_NUMBER .)
    NOT_EQUALS      reduce using rule 51 (number -> OCTAL_NUMBER .)
    GREATER_THEN    reduce using rule 51 (number -> OCTAL_NUMBER .)
    LESS_THEN       reduce using rule 51 (number -> OCTAL_NUMBER .)
    LESS_EQUALS     reduce using rule 51 (number -> OCTAL_NUMBER .)
    GREATER_EQUALS  reduce using rule 51 (number -> OCTAL_NUMBER .)
    LPAREN          reduce using rule 51 (number -> OCTAL_NUMBER .)
    IDENTIFIER      reduce using rule 51 (number -> OCTAL_NUMBER .)
    STRING          reduce using rule 51 (number -> OCTAL_NUMBER .)
    CHARACTER       reduce using rule 51 (number -> OCTAL_NUMBER .)
    NOT             reduce using rule 51 (number -> OCTAL_NUMBER .)
    NUMBER          reduce using rule 51 (number -> OCTAL_NUMBER .)
    FLOAT_NUMBER    reduce using rule 51 (number -> OCTAL_NUMBER .)
    BINARY_NUMBER   reduce using rule 51 (number -> OCTAL_NUMBER .)
    HEXADECIMAL_NUMBER reduce using rule 51 (number -> OCTAL_NUMBER .)
    OCTAL_NUMBER    reduce using rule 51 (number -> OCTAL_NUMBER .)
    TYPE_CHAR       reduce using rule 51 (number -> OCTAL_NUMBER .)
    TYPE_DOUBLE     reduce using rule 51 (number -> OCTAL_NUMBER .)
    TYPE_FLOAT      reduce using rule 51 (number -> OCTAL_NUMBER .)
    TYPE_INT        reduce using rule 51 (number -> OCTAL_NUMBER .)
    TYPE_LONG       reduce using rule 51 (number -> OCTAL_NUMBER .)
    TYPE_SHORT      reduce using rule 51 (number -> OCTAL_NUMBER .)
    TYPE_VOID       reduce using rule 51 (number -> OCTAL_NUMBER .)
    KEYWORD_STRUCT  reduce using rule 51 (number -> OCTAL_NUMBER .)
    RPAREN          reduce using rule 51 (number -> OCTAL_NUMBER .)


state 69

    (53) signature -> type IDENTIFIER function_parameters .

    SEMICOLON       reduce using rule 53 (signature -> type IDENTIFIER function_parameters .)
    LBRACE          reduce using rule 53 (signature -> type IDENTIFIER function_parameters .)


state 70

    (55) function_parameters -> LPAREN . parameters_list RPAREN
    (56) function_parameters -> LPAREN . RPAREN
    (57) parameters_list -> . data_definition COMMA parameters_list
    (58) parameters_list -> . data_definition
    (59) parameters_list -> . array_definition COMMA parameters_list
    (60) parameters_list -> . array_definition
    (61) parameters_list -> . array_declaration COMMA parameters_list
    (62) parameters_list -> . array_declaration
    (65) data_definition -> . type IDENTIFIER
    (66) data_definition -> . pointer IDENTIFIER
    (67) array_definition -> . static_array_definition
    (68) array_definition -> . runtime_array_definition
    (63) array_declaration -> . type IDENTIFIER LBRACKET RBRACKET
    (64) array_declaration -> . pointer IDENTIFIER LBRACKET RBRACKET
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (69) static_array_definition -> . type IDENTIFIER LBRACKET NUMBER RBRACKET
    (70) static_array_definition -> . pointer IDENTIFIER LBRACKET NUMBER RBRACKET
    (71) runtime_array_definition -> . type IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (72) runtime_array_definition -> . pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    RPAREN          shift and go to state 112
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    IDENTIFIER      shift and go to state 6
    KEYWORD_STRUCT  shift and go to state 17

    parameters_list                shift and go to state 111
    data_definition                shift and go to state 113
    array_definition               shift and go to state 114
    array_declaration              shift and go to state 115
    type                           shift and go to state 116
    pointer                        shift and go to state 117
    static_array_definition        shift and go to state 44
    runtime_array_definition       shift and go to state 45
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 71

    (86) multiple_pointer -> TIMES . multiple_pointer
    (87) multiple_pointer -> TIMES .
    (86) multiple_pointer -> . TIMES multiple_pointer
    (87) multiple_pointer -> . TIMES

    IDENTIFIER      reduce using rule 87 (multiple_pointer -> TIMES .)
    TIMES           shift and go to state 71

    multiple_pointer               shift and go to state 118

state 72

    (84) pointer -> type TIMES multiple_pointer .

    IDENTIFIER      reduce using rule 84 (pointer -> type TIMES multiple_pointer .)


state 73

    (54) signature -> pointer IDENTIFIER function_parameters .

    SEMICOLON       reduce using rule 54 (signature -> pointer IDENTIFIER function_parameters .)
    LBRACE          reduce using rule 54 (signature -> pointer IDENTIFIER function_parameters .)


state 74

    (5) command_block -> LBRACE commands RBRACE .

    TYPE_CHAR       reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    TYPE_DOUBLE     reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    TYPE_FLOAT      reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    TYPE_INT        reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    TYPE_LONG       reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    TYPE_SHORT      reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    TYPE_VOID       reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    IDENTIFIER      reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    KEYWORD_STRUCT  reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    $end            reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    SEMICOLON       reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    NOT             reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    LBRACE          reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    KEYWORD_WHILE   reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    LOGICAL_AND     reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    LOGICAL_OR      reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    PLUS            reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    MINUS           reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    TIMES           reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    DIVIDE          reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    MODULUS         reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    EQUALS_THEN     reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    NOT_EQUALS      reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    GREATER_THEN    reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    LESS_THEN       reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    LESS_EQUALS     reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    GREATER_EQUALS  reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    LPAREN          reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    STRING          reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    CHARACTER       reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    NUMBER          reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    FLOAT_NUMBER    reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    BINARY_NUMBER   reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    HEXADECIMAL_NUMBER reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    OCTAL_NUMBER    reduce using rule 5 (command_block -> LBRACE commands RBRACE .)
    RBRACE          reduce using rule 5 (command_block -> LBRACE commands RBRACE .)


state 75

    (7) commands -> command commands .

    RBRACE          reduce using rule 7 (commands -> command commands .)


state 76

    (9) command -> data_definition SEMICOLON .

    SEMICOLON       reduce using rule 9 (command -> data_definition SEMICOLON .)
    IDENTIFIER      reduce using rule 9 (command -> data_definition SEMICOLON .)
    NOT             reduce using rule 9 (command -> data_definition SEMICOLON .)
    LBRACE          reduce using rule 9 (command -> data_definition SEMICOLON .)
    KEYWORD_WHILE   reduce using rule 9 (command -> data_definition SEMICOLON .)
    LOGICAL_AND     reduce using rule 9 (command -> data_definition SEMICOLON .)
    LOGICAL_OR      reduce using rule 9 (command -> data_definition SEMICOLON .)
    PLUS            reduce using rule 9 (command -> data_definition SEMICOLON .)
    MINUS           reduce using rule 9 (command -> data_definition SEMICOLON .)
    TIMES           reduce using rule 9 (command -> data_definition SEMICOLON .)
    DIVIDE          reduce using rule 9 (command -> data_definition SEMICOLON .)
    MODULUS         reduce using rule 9 (command -> data_definition SEMICOLON .)
    EQUALS_THEN     reduce using rule 9 (command -> data_definition SEMICOLON .)
    NOT_EQUALS      reduce using rule 9 (command -> data_definition SEMICOLON .)
    GREATER_THEN    reduce using rule 9 (command -> data_definition SEMICOLON .)
    LESS_THEN       reduce using rule 9 (command -> data_definition SEMICOLON .)
    LESS_EQUALS     reduce using rule 9 (command -> data_definition SEMICOLON .)
    GREATER_EQUALS  reduce using rule 9 (command -> data_definition SEMICOLON .)
    LPAREN          reduce using rule 9 (command -> data_definition SEMICOLON .)
    STRING          reduce using rule 9 (command -> data_definition SEMICOLON .)
    CHARACTER       reduce using rule 9 (command -> data_definition SEMICOLON .)
    TYPE_CHAR       reduce using rule 9 (command -> data_definition SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 9 (command -> data_definition SEMICOLON .)
    TYPE_FLOAT      reduce using rule 9 (command -> data_definition SEMICOLON .)
    TYPE_INT        reduce using rule 9 (command -> data_definition SEMICOLON .)
    TYPE_LONG       reduce using rule 9 (command -> data_definition SEMICOLON .)
    TYPE_SHORT      reduce using rule 9 (command -> data_definition SEMICOLON .)
    TYPE_VOID       reduce using rule 9 (command -> data_definition SEMICOLON .)
    KEYWORD_STRUCT  reduce using rule 9 (command -> data_definition SEMICOLON .)
    NUMBER          reduce using rule 9 (command -> data_definition SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 9 (command -> data_definition SEMICOLON .)
    BINARY_NUMBER   reduce using rule 9 (command -> data_definition SEMICOLON .)
    HEXADECIMAL_NUMBER reduce using rule 9 (command -> data_definition SEMICOLON .)
    OCTAL_NUMBER    reduce using rule 9 (command -> data_definition SEMICOLON .)
    RBRACE          reduce using rule 9 (command -> data_definition SEMICOLON .)


state 77

    (11) command -> assign SEMICOLON .

    SEMICOLON       reduce using rule 11 (command -> assign SEMICOLON .)
    IDENTIFIER      reduce using rule 11 (command -> assign SEMICOLON .)
    NOT             reduce using rule 11 (command -> assign SEMICOLON .)
    LBRACE          reduce using rule 11 (command -> assign SEMICOLON .)
    KEYWORD_WHILE   reduce using rule 11 (command -> assign SEMICOLON .)
    LOGICAL_AND     reduce using rule 11 (command -> assign SEMICOLON .)
    LOGICAL_OR      reduce using rule 11 (command -> assign SEMICOLON .)
    PLUS            reduce using rule 11 (command -> assign SEMICOLON .)
    MINUS           reduce using rule 11 (command -> assign SEMICOLON .)
    TIMES           reduce using rule 11 (command -> assign SEMICOLON .)
    DIVIDE          reduce using rule 11 (command -> assign SEMICOLON .)
    MODULUS         reduce using rule 11 (command -> assign SEMICOLON .)
    EQUALS_THEN     reduce using rule 11 (command -> assign SEMICOLON .)
    NOT_EQUALS      reduce using rule 11 (command -> assign SEMICOLON .)
    GREATER_THEN    reduce using rule 11 (command -> assign SEMICOLON .)
    LESS_THEN       reduce using rule 11 (command -> assign SEMICOLON .)
    LESS_EQUALS     reduce using rule 11 (command -> assign SEMICOLON .)
    GREATER_EQUALS  reduce using rule 11 (command -> assign SEMICOLON .)
    LPAREN          reduce using rule 11 (command -> assign SEMICOLON .)
    STRING          reduce using rule 11 (command -> assign SEMICOLON .)
    CHARACTER       reduce using rule 11 (command -> assign SEMICOLON .)
    TYPE_CHAR       reduce using rule 11 (command -> assign SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 11 (command -> assign SEMICOLON .)
    TYPE_FLOAT      reduce using rule 11 (command -> assign SEMICOLON .)
    TYPE_INT        reduce using rule 11 (command -> assign SEMICOLON .)
    TYPE_LONG       reduce using rule 11 (command -> assign SEMICOLON .)
    TYPE_SHORT      reduce using rule 11 (command -> assign SEMICOLON .)
    TYPE_VOID       reduce using rule 11 (command -> assign SEMICOLON .)
    KEYWORD_STRUCT  reduce using rule 11 (command -> assign SEMICOLON .)
    NUMBER          reduce using rule 11 (command -> assign SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 11 (command -> assign SEMICOLON .)
    BINARY_NUMBER   reduce using rule 11 (command -> assign SEMICOLON .)
    HEXADECIMAL_NUMBER reduce using rule 11 (command -> assign SEMICOLON .)
    OCTAL_NUMBER    reduce using rule 11 (command -> assign SEMICOLON .)
    RBRACE          reduce using rule 11 (command -> assign SEMICOLON .)


state 78

    (12) command -> define_and_assign SEMICOLON .

    SEMICOLON       reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    NOT             reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    LBRACE          reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    KEYWORD_WHILE   reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    LOGICAL_AND     reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    LOGICAL_OR      reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    PLUS            reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    MINUS           reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    TIMES           reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    DIVIDE          reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    MODULUS         reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    EQUALS_THEN     reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    NOT_EQUALS      reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    GREATER_THEN    reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    LESS_THEN       reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    LESS_EQUALS     reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    GREATER_EQUALS  reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    LPAREN          reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    STRING          reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    CHARACTER       reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    TYPE_CHAR       reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    TYPE_FLOAT      reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    TYPE_INT        reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    TYPE_LONG       reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    TYPE_SHORT      reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    TYPE_VOID       reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    KEYWORD_STRUCT  reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    NUMBER          reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    BINARY_NUMBER   reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    HEXADECIMAL_NUMBER reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    OCTAL_NUMBER    reduce using rule 12 (command -> define_and_assign SEMICOLON .)
    RBRACE          reduce using rule 12 (command -> define_and_assign SEMICOLON .)


state 79

    (40) expression2 -> expression .
    (17) expression -> expression . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       reduce using rule 40 (expression2 -> expression .)
    RPAREN          reduce using rule 40 (expression2 -> expression .)
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 80

    (13) command -> expression SEMICOLON .

    SEMICOLON       reduce using rule 13 (command -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 13 (command -> expression SEMICOLON .)
    NOT             reduce using rule 13 (command -> expression SEMICOLON .)
    LBRACE          reduce using rule 13 (command -> expression SEMICOLON .)
    KEYWORD_WHILE   reduce using rule 13 (command -> expression SEMICOLON .)
    LOGICAL_AND     reduce using rule 13 (command -> expression SEMICOLON .)
    LOGICAL_OR      reduce using rule 13 (command -> expression SEMICOLON .)
    PLUS            reduce using rule 13 (command -> expression SEMICOLON .)
    MINUS           reduce using rule 13 (command -> expression SEMICOLON .)
    TIMES           reduce using rule 13 (command -> expression SEMICOLON .)
    DIVIDE          reduce using rule 13 (command -> expression SEMICOLON .)
    MODULUS         reduce using rule 13 (command -> expression SEMICOLON .)
    EQUALS_THEN     reduce using rule 13 (command -> expression SEMICOLON .)
    NOT_EQUALS      reduce using rule 13 (command -> expression SEMICOLON .)
    GREATER_THEN    reduce using rule 13 (command -> expression SEMICOLON .)
    LESS_THEN       reduce using rule 13 (command -> expression SEMICOLON .)
    LESS_EQUALS     reduce using rule 13 (command -> expression SEMICOLON .)
    GREATER_EQUALS  reduce using rule 13 (command -> expression SEMICOLON .)
    LPAREN          reduce using rule 13 (command -> expression SEMICOLON .)
    STRING          reduce using rule 13 (command -> expression SEMICOLON .)
    CHARACTER       reduce using rule 13 (command -> expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 13 (command -> expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 13 (command -> expression SEMICOLON .)
    TYPE_FLOAT      reduce using rule 13 (command -> expression SEMICOLON .)
    TYPE_INT        reduce using rule 13 (command -> expression SEMICOLON .)
    TYPE_LONG       reduce using rule 13 (command -> expression SEMICOLON .)
    TYPE_SHORT      reduce using rule 13 (command -> expression SEMICOLON .)
    TYPE_VOID       reduce using rule 13 (command -> expression SEMICOLON .)
    KEYWORD_STRUCT  reduce using rule 13 (command -> expression SEMICOLON .)
    NUMBER          reduce using rule 13 (command -> expression SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 13 (command -> expression SEMICOLON .)
    BINARY_NUMBER   reduce using rule 13 (command -> expression SEMICOLON .)
    HEXADECIMAL_NUMBER reduce using rule 13 (command -> expression SEMICOLON .)
    OCTAL_NUMBER    reduce using rule 13 (command -> expression SEMICOLON .)
    RBRACE          reduce using rule 13 (command -> expression SEMICOLON .)


state 81

    (17) expression -> expression expression2 .
    (19) expression -> expression2 .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for PLUS resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for MINUS resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for TIMES resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for MODULUS resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for LPAREN resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for STRING resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for NOT resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for NUMBER resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 17 (expression -> expression expression2 .)
  ! reduce/reduce conflict for RPAREN resolved using rule 17 (expression -> expression expression2 .)
    SEMICOLON       reduce using rule 17 (expression -> expression expression2 .)
    LOGICAL_AND     reduce using rule 17 (expression -> expression expression2 .)
    LOGICAL_OR      reduce using rule 17 (expression -> expression expression2 .)
    PLUS            reduce using rule 17 (expression -> expression expression2 .)
    MINUS           reduce using rule 17 (expression -> expression expression2 .)
    TIMES           reduce using rule 17 (expression -> expression expression2 .)
    DIVIDE          reduce using rule 17 (expression -> expression expression2 .)
    MODULUS         reduce using rule 17 (expression -> expression expression2 .)
    EQUALS_THEN     reduce using rule 17 (expression -> expression expression2 .)
    NOT_EQUALS      reduce using rule 17 (expression -> expression expression2 .)
    GREATER_THEN    reduce using rule 17 (expression -> expression expression2 .)
    LESS_THEN       reduce using rule 17 (expression -> expression expression2 .)
    LESS_EQUALS     reduce using rule 17 (expression -> expression expression2 .)
    GREATER_EQUALS  reduce using rule 17 (expression -> expression expression2 .)
    LPAREN          reduce using rule 17 (expression -> expression expression2 .)
    IDENTIFIER      reduce using rule 17 (expression -> expression expression2 .)
    STRING          reduce using rule 17 (expression -> expression expression2 .)
    CHARACTER       reduce using rule 17 (expression -> expression expression2 .)
    NOT             reduce using rule 17 (expression -> expression expression2 .)
    NUMBER          reduce using rule 17 (expression -> expression expression2 .)
    FLOAT_NUMBER    reduce using rule 17 (expression -> expression expression2 .)
    BINARY_NUMBER   reduce using rule 17 (expression -> expression expression2 .)
    HEXADECIMAL_NUMBER reduce using rule 17 (expression -> expression expression2 .)
    OCTAL_NUMBER    reduce using rule 17 (expression -> expression expression2 .)
    TYPE_CHAR       reduce using rule 17 (expression -> expression expression2 .)
    TYPE_DOUBLE     reduce using rule 17 (expression -> expression expression2 .)
    TYPE_FLOAT      reduce using rule 17 (expression -> expression expression2 .)
    TYPE_INT        reduce using rule 17 (expression -> expression expression2 .)
    TYPE_LONG       reduce using rule 17 (expression -> expression expression2 .)
    TYPE_SHORT      reduce using rule 17 (expression -> expression expression2 .)
    TYPE_VOID       reduce using rule 17 (expression -> expression expression2 .)
    KEYWORD_STRUCT  reduce using rule 17 (expression -> expression expression2 .)
    RPAREN          reduce using rule 17 (expression -> expression expression2 .)

  ! SEMICOLON       [ reduce using rule 19 (expression -> expression2 .) ]
  ! LOGICAL_AND     [ reduce using rule 19 (expression -> expression2 .) ]
  ! LOGICAL_OR      [ reduce using rule 19 (expression -> expression2 .) ]
  ! PLUS            [ reduce using rule 19 (expression -> expression2 .) ]
  ! MINUS           [ reduce using rule 19 (expression -> expression2 .) ]
  ! TIMES           [ reduce using rule 19 (expression -> expression2 .) ]
  ! DIVIDE          [ reduce using rule 19 (expression -> expression2 .) ]
  ! MODULUS         [ reduce using rule 19 (expression -> expression2 .) ]
  ! EQUALS_THEN     [ reduce using rule 19 (expression -> expression2 .) ]
  ! NOT_EQUALS      [ reduce using rule 19 (expression -> expression2 .) ]
  ! GREATER_THEN    [ reduce using rule 19 (expression -> expression2 .) ]
  ! LESS_THEN       [ reduce using rule 19 (expression -> expression2 .) ]
  ! LESS_EQUALS     [ reduce using rule 19 (expression -> expression2 .) ]
  ! GREATER_EQUALS  [ reduce using rule 19 (expression -> expression2 .) ]
  ! LPAREN          [ reduce using rule 19 (expression -> expression2 .) ]
  ! IDENTIFIER      [ reduce using rule 19 (expression -> expression2 .) ]
  ! STRING          [ reduce using rule 19 (expression -> expression2 .) ]
  ! CHARACTER       [ reduce using rule 19 (expression -> expression2 .) ]
  ! NOT             [ reduce using rule 19 (expression -> expression2 .) ]
  ! NUMBER          [ reduce using rule 19 (expression -> expression2 .) ]
  ! FLOAT_NUMBER    [ reduce using rule 19 (expression -> expression2 .) ]
  ! BINARY_NUMBER   [ reduce using rule 19 (expression -> expression2 .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 19 (expression -> expression2 .) ]
  ! OCTAL_NUMBER    [ reduce using rule 19 (expression -> expression2 .) ]
  ! TYPE_CHAR       [ reduce using rule 19 (expression -> expression2 .) ]
  ! TYPE_DOUBLE     [ reduce using rule 19 (expression -> expression2 .) ]
  ! TYPE_FLOAT      [ reduce using rule 19 (expression -> expression2 .) ]
  ! TYPE_INT        [ reduce using rule 19 (expression -> expression2 .) ]
  ! TYPE_LONG       [ reduce using rule 19 (expression -> expression2 .) ]
  ! TYPE_SHORT      [ reduce using rule 19 (expression -> expression2 .) ]
  ! TYPE_VOID       [ reduce using rule 19 (expression -> expression2 .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 19 (expression -> expression2 .) ]
  ! RPAREN          [ reduce using rule 19 (expression -> expression2 .) ]


state 82

    (41) expression2 -> IDENTIFIER .
    (23) assign -> IDENTIFIER . ASSIGN expression
    (82) user_types -> IDENTIFIER .

  ! reduce/reduce conflict for TIMES resolved using rule 41 (expression2 -> IDENTIFIER .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 41 (expression2 -> IDENTIFIER .)
    SEMICOLON       reduce using rule 41 (expression2 -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 41 (expression2 -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 41 (expression2 -> IDENTIFIER .)
    PLUS            reduce using rule 41 (expression2 -> IDENTIFIER .)
    MINUS           reduce using rule 41 (expression2 -> IDENTIFIER .)
    TIMES           reduce using rule 41 (expression2 -> IDENTIFIER .)
    DIVIDE          reduce using rule 41 (expression2 -> IDENTIFIER .)
    MODULUS         reduce using rule 41 (expression2 -> IDENTIFIER .)
    EQUALS_THEN     reduce using rule 41 (expression2 -> IDENTIFIER .)
    NOT_EQUALS      reduce using rule 41 (expression2 -> IDENTIFIER .)
    GREATER_THEN    reduce using rule 41 (expression2 -> IDENTIFIER .)
    LESS_THEN       reduce using rule 41 (expression2 -> IDENTIFIER .)
    LESS_EQUALS     reduce using rule 41 (expression2 -> IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 41 (expression2 -> IDENTIFIER .)
    LPAREN          reduce using rule 41 (expression2 -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 41 (expression2 -> IDENTIFIER .)
    STRING          reduce using rule 41 (expression2 -> IDENTIFIER .)
    CHARACTER       reduce using rule 41 (expression2 -> IDENTIFIER .)
    NOT             reduce using rule 41 (expression2 -> IDENTIFIER .)
    NUMBER          reduce using rule 41 (expression2 -> IDENTIFIER .)
    FLOAT_NUMBER    reduce using rule 41 (expression2 -> IDENTIFIER .)
    BINARY_NUMBER   reduce using rule 41 (expression2 -> IDENTIFIER .)
    HEXADECIMAL_NUMBER reduce using rule 41 (expression2 -> IDENTIFIER .)
    OCTAL_NUMBER    reduce using rule 41 (expression2 -> IDENTIFIER .)
    TYPE_CHAR       reduce using rule 41 (expression2 -> IDENTIFIER .)
    TYPE_DOUBLE     reduce using rule 41 (expression2 -> IDENTIFIER .)
    TYPE_FLOAT      reduce using rule 41 (expression2 -> IDENTIFIER .)
    TYPE_INT        reduce using rule 41 (expression2 -> IDENTIFIER .)
    TYPE_LONG       reduce using rule 41 (expression2 -> IDENTIFIER .)
    TYPE_SHORT      reduce using rule 41 (expression2 -> IDENTIFIER .)
    TYPE_VOID       reduce using rule 41 (expression2 -> IDENTIFIER .)
    KEYWORD_STRUCT  reduce using rule 41 (expression2 -> IDENTIFIER .)
    RPAREN          reduce using rule 41 (expression2 -> IDENTIFIER .)
    ASSIGN          shift and go to state 90

  ! TIMES           [ reduce using rule 82 (user_types -> IDENTIFIER .) ]
  ! IDENTIFIER      [ reduce using rule 82 (user_types -> IDENTIFIER .) ]


state 83

    (45) expression2 -> assign .

    SEMICOLON       reduce using rule 45 (expression2 -> assign .)
    LOGICAL_AND     reduce using rule 45 (expression2 -> assign .)
    LOGICAL_OR      reduce using rule 45 (expression2 -> assign .)
    PLUS            reduce using rule 45 (expression2 -> assign .)
    MINUS           reduce using rule 45 (expression2 -> assign .)
    TIMES           reduce using rule 45 (expression2 -> assign .)
    DIVIDE          reduce using rule 45 (expression2 -> assign .)
    MODULUS         reduce using rule 45 (expression2 -> assign .)
    EQUALS_THEN     reduce using rule 45 (expression2 -> assign .)
    NOT_EQUALS      reduce using rule 45 (expression2 -> assign .)
    GREATER_THEN    reduce using rule 45 (expression2 -> assign .)
    LESS_THEN       reduce using rule 45 (expression2 -> assign .)
    LESS_EQUALS     reduce using rule 45 (expression2 -> assign .)
    GREATER_EQUALS  reduce using rule 45 (expression2 -> assign .)
    LPAREN          reduce using rule 45 (expression2 -> assign .)
    IDENTIFIER      reduce using rule 45 (expression2 -> assign .)
    STRING          reduce using rule 45 (expression2 -> assign .)
    CHARACTER       reduce using rule 45 (expression2 -> assign .)
    NOT             reduce using rule 45 (expression2 -> assign .)
    NUMBER          reduce using rule 45 (expression2 -> assign .)
    FLOAT_NUMBER    reduce using rule 45 (expression2 -> assign .)
    BINARY_NUMBER   reduce using rule 45 (expression2 -> assign .)
    HEXADECIMAL_NUMBER reduce using rule 45 (expression2 -> assign .)
    OCTAL_NUMBER    reduce using rule 45 (expression2 -> assign .)
    TYPE_CHAR       reduce using rule 45 (expression2 -> assign .)
    TYPE_DOUBLE     reduce using rule 45 (expression2 -> assign .)
    TYPE_FLOAT      reduce using rule 45 (expression2 -> assign .)
    TYPE_INT        reduce using rule 45 (expression2 -> assign .)
    TYPE_LONG       reduce using rule 45 (expression2 -> assign .)
    TYPE_SHORT      reduce using rule 45 (expression2 -> assign .)
    TYPE_VOID       reduce using rule 45 (expression2 -> assign .)
    KEYWORD_STRUCT  reduce using rule 45 (expression2 -> assign .)
    RPAREN          reduce using rule 45 (expression2 -> assign .)


state 84

    (46) expression2 -> define_and_assign .

    SEMICOLON       reduce using rule 46 (expression2 -> define_and_assign .)
    LOGICAL_AND     reduce using rule 46 (expression2 -> define_and_assign .)
    LOGICAL_OR      reduce using rule 46 (expression2 -> define_and_assign .)
    PLUS            reduce using rule 46 (expression2 -> define_and_assign .)
    MINUS           reduce using rule 46 (expression2 -> define_and_assign .)
    TIMES           reduce using rule 46 (expression2 -> define_and_assign .)
    DIVIDE          reduce using rule 46 (expression2 -> define_and_assign .)
    MODULUS         reduce using rule 46 (expression2 -> define_and_assign .)
    EQUALS_THEN     reduce using rule 46 (expression2 -> define_and_assign .)
    NOT_EQUALS      reduce using rule 46 (expression2 -> define_and_assign .)
    GREATER_THEN    reduce using rule 46 (expression2 -> define_and_assign .)
    LESS_THEN       reduce using rule 46 (expression2 -> define_and_assign .)
    LESS_EQUALS     reduce using rule 46 (expression2 -> define_and_assign .)
    GREATER_EQUALS  reduce using rule 46 (expression2 -> define_and_assign .)
    LPAREN          reduce using rule 46 (expression2 -> define_and_assign .)
    IDENTIFIER      reduce using rule 46 (expression2 -> define_and_assign .)
    STRING          reduce using rule 46 (expression2 -> define_and_assign .)
    CHARACTER       reduce using rule 46 (expression2 -> define_and_assign .)
    NOT             reduce using rule 46 (expression2 -> define_and_assign .)
    NUMBER          reduce using rule 46 (expression2 -> define_and_assign .)
    FLOAT_NUMBER    reduce using rule 46 (expression2 -> define_and_assign .)
    BINARY_NUMBER   reduce using rule 46 (expression2 -> define_and_assign .)
    HEXADECIMAL_NUMBER reduce using rule 46 (expression2 -> define_and_assign .)
    OCTAL_NUMBER    reduce using rule 46 (expression2 -> define_and_assign .)
    TYPE_CHAR       reduce using rule 46 (expression2 -> define_and_assign .)
    TYPE_DOUBLE     reduce using rule 46 (expression2 -> define_and_assign .)
    TYPE_FLOAT      reduce using rule 46 (expression2 -> define_and_assign .)
    TYPE_INT        reduce using rule 46 (expression2 -> define_and_assign .)
    TYPE_LONG       reduce using rule 46 (expression2 -> define_and_assign .)
    TYPE_SHORT      reduce using rule 46 (expression2 -> define_and_assign .)
    TYPE_VOID       reduce using rule 46 (expression2 -> define_and_assign .)
    KEYWORD_STRUCT  reduce using rule 46 (expression2 -> define_and_assign .)
    RPAREN          reduce using rule 46 (expression2 -> define_and_assign .)


state 85

    (24) define_and_assign -> type . assign
    (84) pointer -> type . TIMES multiple_pointer
    (85) pointer -> type . TIMES
    (23) assign -> . IDENTIFIER ASSIGN expression

    TIMES           shift and go to state 24
    IDENTIFIER      shift and go to state 119

    assign                         shift and go to state 89

state 86

    (25) define_and_assign -> pointer . assign
    (23) assign -> . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 119

    assign                         shift and go to state 92

state 87

    (16) command -> array_definition SEMICOLON .

    SEMICOLON       reduce using rule 16 (command -> array_definition SEMICOLON .)
    IDENTIFIER      reduce using rule 16 (command -> array_definition SEMICOLON .)
    NOT             reduce using rule 16 (command -> array_definition SEMICOLON .)
    LBRACE          reduce using rule 16 (command -> array_definition SEMICOLON .)
    KEYWORD_WHILE   reduce using rule 16 (command -> array_definition SEMICOLON .)
    LOGICAL_AND     reduce using rule 16 (command -> array_definition SEMICOLON .)
    LOGICAL_OR      reduce using rule 16 (command -> array_definition SEMICOLON .)
    PLUS            reduce using rule 16 (command -> array_definition SEMICOLON .)
    MINUS           reduce using rule 16 (command -> array_definition SEMICOLON .)
    TIMES           reduce using rule 16 (command -> array_definition SEMICOLON .)
    DIVIDE          reduce using rule 16 (command -> array_definition SEMICOLON .)
    MODULUS         reduce using rule 16 (command -> array_definition SEMICOLON .)
    EQUALS_THEN     reduce using rule 16 (command -> array_definition SEMICOLON .)
    NOT_EQUALS      reduce using rule 16 (command -> array_definition SEMICOLON .)
    GREATER_THEN    reduce using rule 16 (command -> array_definition SEMICOLON .)
    LESS_THEN       reduce using rule 16 (command -> array_definition SEMICOLON .)
    LESS_EQUALS     reduce using rule 16 (command -> array_definition SEMICOLON .)
    GREATER_EQUALS  reduce using rule 16 (command -> array_definition SEMICOLON .)
    LPAREN          reduce using rule 16 (command -> array_definition SEMICOLON .)
    STRING          reduce using rule 16 (command -> array_definition SEMICOLON .)
    CHARACTER       reduce using rule 16 (command -> array_definition SEMICOLON .)
    TYPE_CHAR       reduce using rule 16 (command -> array_definition SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 16 (command -> array_definition SEMICOLON .)
    TYPE_FLOAT      reduce using rule 16 (command -> array_definition SEMICOLON .)
    TYPE_INT        reduce using rule 16 (command -> array_definition SEMICOLON .)
    TYPE_LONG       reduce using rule 16 (command -> array_definition SEMICOLON .)
    TYPE_SHORT      reduce using rule 16 (command -> array_definition SEMICOLON .)
    TYPE_VOID       reduce using rule 16 (command -> array_definition SEMICOLON .)
    KEYWORD_STRUCT  reduce using rule 16 (command -> array_definition SEMICOLON .)
    NUMBER          reduce using rule 16 (command -> array_definition SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 16 (command -> array_definition SEMICOLON .)
    BINARY_NUMBER   reduce using rule 16 (command -> array_definition SEMICOLON .)
    HEXADECIMAL_NUMBER reduce using rule 16 (command -> array_definition SEMICOLON .)
    OCTAL_NUMBER    reduce using rule 16 (command -> array_definition SEMICOLON .)
    RBRACE          reduce using rule 16 (command -> array_definition SEMICOLON .)


state 88

    (65) data_definition -> type IDENTIFIER .
    (69) static_array_definition -> type IDENTIFIER . LBRACKET NUMBER RBRACKET
    (71) runtime_array_definition -> type IDENTIFIER . LBRACKET IDENTIFIER RBRACKET
    (23) assign -> IDENTIFIER . ASSIGN expression

    SEMICOLON       reduce using rule 65 (data_definition -> type IDENTIFIER .)
    LBRACKET        shift and go to state 120
    ASSIGN          shift and go to state 90


state 89

    (24) define_and_assign -> type assign .

    SEMICOLON       reduce using rule 24 (define_and_assign -> type assign .)
    LOGICAL_AND     reduce using rule 24 (define_and_assign -> type assign .)
    LOGICAL_OR      reduce using rule 24 (define_and_assign -> type assign .)
    PLUS            reduce using rule 24 (define_and_assign -> type assign .)
    MINUS           reduce using rule 24 (define_and_assign -> type assign .)
    TIMES           reduce using rule 24 (define_and_assign -> type assign .)
    DIVIDE          reduce using rule 24 (define_and_assign -> type assign .)
    MODULUS         reduce using rule 24 (define_and_assign -> type assign .)
    EQUALS_THEN     reduce using rule 24 (define_and_assign -> type assign .)
    NOT_EQUALS      reduce using rule 24 (define_and_assign -> type assign .)
    GREATER_THEN    reduce using rule 24 (define_and_assign -> type assign .)
    LESS_THEN       reduce using rule 24 (define_and_assign -> type assign .)
    LESS_EQUALS     reduce using rule 24 (define_and_assign -> type assign .)
    GREATER_EQUALS  reduce using rule 24 (define_and_assign -> type assign .)
    LPAREN          reduce using rule 24 (define_and_assign -> type assign .)
    IDENTIFIER      reduce using rule 24 (define_and_assign -> type assign .)
    STRING          reduce using rule 24 (define_and_assign -> type assign .)
    CHARACTER       reduce using rule 24 (define_and_assign -> type assign .)
    NOT             reduce using rule 24 (define_and_assign -> type assign .)
    NUMBER          reduce using rule 24 (define_and_assign -> type assign .)
    FLOAT_NUMBER    reduce using rule 24 (define_and_assign -> type assign .)
    BINARY_NUMBER   reduce using rule 24 (define_and_assign -> type assign .)
    HEXADECIMAL_NUMBER reduce using rule 24 (define_and_assign -> type assign .)
    OCTAL_NUMBER    reduce using rule 24 (define_and_assign -> type assign .)
    TYPE_CHAR       reduce using rule 24 (define_and_assign -> type assign .)
    TYPE_DOUBLE     reduce using rule 24 (define_and_assign -> type assign .)
    TYPE_FLOAT      reduce using rule 24 (define_and_assign -> type assign .)
    TYPE_INT        reduce using rule 24 (define_and_assign -> type assign .)
    TYPE_LONG       reduce using rule 24 (define_and_assign -> type assign .)
    TYPE_SHORT      reduce using rule 24 (define_and_assign -> type assign .)
    TYPE_VOID       reduce using rule 24 (define_and_assign -> type assign .)
    KEYWORD_STRUCT  reduce using rule 24 (define_and_assign -> type assign .)
    RPAREN          reduce using rule 24 (define_and_assign -> type assign .)


state 90

    (23) assign -> IDENTIFIER ASSIGN . expression
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 121
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 91

    (66) data_definition -> pointer IDENTIFIER .
    (70) static_array_definition -> pointer IDENTIFIER . LBRACKET NUMBER RBRACKET
    (72) runtime_array_definition -> pointer IDENTIFIER . LBRACKET IDENTIFIER RBRACKET
    (23) assign -> IDENTIFIER . ASSIGN expression

    SEMICOLON       reduce using rule 66 (data_definition -> pointer IDENTIFIER .)
    LBRACKET        shift and go to state 122
    ASSIGN          shift and go to state 90


state 92

    (25) define_and_assign -> pointer assign .

    SEMICOLON       reduce using rule 25 (define_and_assign -> pointer assign .)
    LOGICAL_AND     reduce using rule 25 (define_and_assign -> pointer assign .)
    LOGICAL_OR      reduce using rule 25 (define_and_assign -> pointer assign .)
    PLUS            reduce using rule 25 (define_and_assign -> pointer assign .)
    MINUS           reduce using rule 25 (define_and_assign -> pointer assign .)
    TIMES           reduce using rule 25 (define_and_assign -> pointer assign .)
    DIVIDE          reduce using rule 25 (define_and_assign -> pointer assign .)
    MODULUS         reduce using rule 25 (define_and_assign -> pointer assign .)
    EQUALS_THEN     reduce using rule 25 (define_and_assign -> pointer assign .)
    NOT_EQUALS      reduce using rule 25 (define_and_assign -> pointer assign .)
    GREATER_THEN    reduce using rule 25 (define_and_assign -> pointer assign .)
    LESS_THEN       reduce using rule 25 (define_and_assign -> pointer assign .)
    LESS_EQUALS     reduce using rule 25 (define_and_assign -> pointer assign .)
    GREATER_EQUALS  reduce using rule 25 (define_and_assign -> pointer assign .)
    LPAREN          reduce using rule 25 (define_and_assign -> pointer assign .)
    IDENTIFIER      reduce using rule 25 (define_and_assign -> pointer assign .)
    STRING          reduce using rule 25 (define_and_assign -> pointer assign .)
    CHARACTER       reduce using rule 25 (define_and_assign -> pointer assign .)
    NOT             reduce using rule 25 (define_and_assign -> pointer assign .)
    NUMBER          reduce using rule 25 (define_and_assign -> pointer assign .)
    FLOAT_NUMBER    reduce using rule 25 (define_and_assign -> pointer assign .)
    BINARY_NUMBER   reduce using rule 25 (define_and_assign -> pointer assign .)
    HEXADECIMAL_NUMBER reduce using rule 25 (define_and_assign -> pointer assign .)
    OCTAL_NUMBER    reduce using rule 25 (define_and_assign -> pointer assign .)
    TYPE_CHAR       reduce using rule 25 (define_and_assign -> pointer assign .)
    TYPE_DOUBLE     reduce using rule 25 (define_and_assign -> pointer assign .)
    TYPE_FLOAT      reduce using rule 25 (define_and_assign -> pointer assign .)
    TYPE_INT        reduce using rule 25 (define_and_assign -> pointer assign .)
    TYPE_LONG       reduce using rule 25 (define_and_assign -> pointer assign .)
    TYPE_SHORT      reduce using rule 25 (define_and_assign -> pointer assign .)
    TYPE_VOID       reduce using rule 25 (define_and_assign -> pointer assign .)
    KEYWORD_STRUCT  reduce using rule 25 (define_and_assign -> pointer assign .)
    RPAREN          reduce using rule 25 (define_and_assign -> pointer assign .)


state 93

    (21) while_loop -> while_signature command_block .
    (14) command -> command_block .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for NOT resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for LBRACE resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for KEYWORD_WHILE resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for PLUS resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for MINUS resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for TIMES resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for MODULUS resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for LPAREN resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for STRING resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for NUMBER resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 14 (command -> command_block .)
  ! reduce/reduce conflict for RBRACE resolved using rule 14 (command -> command_block .)
    SEMICOLON       reduce using rule 14 (command -> command_block .)
    IDENTIFIER      reduce using rule 14 (command -> command_block .)
    NOT             reduce using rule 14 (command -> command_block .)
    LBRACE          reduce using rule 14 (command -> command_block .)
    KEYWORD_WHILE   reduce using rule 14 (command -> command_block .)
    LOGICAL_AND     reduce using rule 14 (command -> command_block .)
    LOGICAL_OR      reduce using rule 14 (command -> command_block .)
    PLUS            reduce using rule 14 (command -> command_block .)
    MINUS           reduce using rule 14 (command -> command_block .)
    TIMES           reduce using rule 14 (command -> command_block .)
    DIVIDE          reduce using rule 14 (command -> command_block .)
    MODULUS         reduce using rule 14 (command -> command_block .)
    EQUALS_THEN     reduce using rule 14 (command -> command_block .)
    NOT_EQUALS      reduce using rule 14 (command -> command_block .)
    GREATER_THEN    reduce using rule 14 (command -> command_block .)
    LESS_THEN       reduce using rule 14 (command -> command_block .)
    LESS_EQUALS     reduce using rule 14 (command -> command_block .)
    GREATER_EQUALS  reduce using rule 14 (command -> command_block .)
    LPAREN          reduce using rule 14 (command -> command_block .)
    STRING          reduce using rule 14 (command -> command_block .)
    CHARACTER       reduce using rule 14 (command -> command_block .)
    TYPE_CHAR       reduce using rule 14 (command -> command_block .)
    TYPE_DOUBLE     reduce using rule 14 (command -> command_block .)
    TYPE_FLOAT      reduce using rule 14 (command -> command_block .)
    TYPE_INT        reduce using rule 14 (command -> command_block .)
    TYPE_LONG       reduce using rule 14 (command -> command_block .)
    TYPE_SHORT      reduce using rule 14 (command -> command_block .)
    TYPE_VOID       reduce using rule 14 (command -> command_block .)
    KEYWORD_STRUCT  reduce using rule 14 (command -> command_block .)
    NUMBER          reduce using rule 14 (command -> command_block .)
    FLOAT_NUMBER    reduce using rule 14 (command -> command_block .)
    BINARY_NUMBER   reduce using rule 14 (command -> command_block .)
    HEXADECIMAL_NUMBER reduce using rule 14 (command -> command_block .)
    OCTAL_NUMBER    reduce using rule 14 (command -> command_block .)
    RBRACE          reduce using rule 14 (command -> command_block .)

  ! SEMICOLON       [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! IDENTIFIER      [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! NOT             [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! LBRACE          [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! KEYWORD_WHILE   [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! LOGICAL_AND     [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! LOGICAL_OR      [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! PLUS            [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! MINUS           [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! TIMES           [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! DIVIDE          [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! MODULUS         [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! EQUALS_THEN     [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! NOT_EQUALS      [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! GREATER_THEN    [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! LESS_THEN       [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! LESS_EQUALS     [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! GREATER_EQUALS  [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! LPAREN          [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! STRING          [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! CHARACTER       [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! TYPE_CHAR       [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! TYPE_DOUBLE     [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! TYPE_FLOAT      [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! TYPE_INT        [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! TYPE_LONG       [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! TYPE_SHORT      [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! TYPE_VOID       [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! NUMBER          [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! FLOAT_NUMBER    [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! BINARY_NUMBER   [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! OCTAL_NUMBER    [ reduce using rule 21 (while_loop -> while_signature command_block .) ]
  ! RBRACE          [ reduce using rule 21 (while_loop -> while_signature command_block .) ]


state 94

    (22) while_loop -> while_signature command .

    SEMICOLON       reduce using rule 22 (while_loop -> while_signature command .)
    IDENTIFIER      reduce using rule 22 (while_loop -> while_signature command .)
    NOT             reduce using rule 22 (while_loop -> while_signature command .)
    LBRACE          reduce using rule 22 (while_loop -> while_signature command .)
    KEYWORD_WHILE   reduce using rule 22 (while_loop -> while_signature command .)
    LOGICAL_AND     reduce using rule 22 (while_loop -> while_signature command .)
    LOGICAL_OR      reduce using rule 22 (while_loop -> while_signature command .)
    PLUS            reduce using rule 22 (while_loop -> while_signature command .)
    MINUS           reduce using rule 22 (while_loop -> while_signature command .)
    TIMES           reduce using rule 22 (while_loop -> while_signature command .)
    DIVIDE          reduce using rule 22 (while_loop -> while_signature command .)
    MODULUS         reduce using rule 22 (while_loop -> while_signature command .)
    EQUALS_THEN     reduce using rule 22 (while_loop -> while_signature command .)
    NOT_EQUALS      reduce using rule 22 (while_loop -> while_signature command .)
    GREATER_THEN    reduce using rule 22 (while_loop -> while_signature command .)
    LESS_THEN       reduce using rule 22 (while_loop -> while_signature command .)
    LESS_EQUALS     reduce using rule 22 (while_loop -> while_signature command .)
    GREATER_EQUALS  reduce using rule 22 (while_loop -> while_signature command .)
    LPAREN          reduce using rule 22 (while_loop -> while_signature command .)
    STRING          reduce using rule 22 (while_loop -> while_signature command .)
    CHARACTER       reduce using rule 22 (while_loop -> while_signature command .)
    TYPE_CHAR       reduce using rule 22 (while_loop -> while_signature command .)
    TYPE_DOUBLE     reduce using rule 22 (while_loop -> while_signature command .)
    TYPE_FLOAT      reduce using rule 22 (while_loop -> while_signature command .)
    TYPE_INT        reduce using rule 22 (while_loop -> while_signature command .)
    TYPE_LONG       reduce using rule 22 (while_loop -> while_signature command .)
    TYPE_SHORT      reduce using rule 22 (while_loop -> while_signature command .)
    TYPE_VOID       reduce using rule 22 (while_loop -> while_signature command .)
    KEYWORD_STRUCT  reduce using rule 22 (while_loop -> while_signature command .)
    NUMBER          reduce using rule 22 (while_loop -> while_signature command .)
    FLOAT_NUMBER    reduce using rule 22 (while_loop -> while_signature command .)
    BINARY_NUMBER   reduce using rule 22 (while_loop -> while_signature command .)
    HEXADECIMAL_NUMBER reduce using rule 22 (while_loop -> while_signature command .)
    OCTAL_NUMBER    reduce using rule 22 (while_loop -> while_signature command .)
    RBRACE          reduce using rule 22 (while_loop -> while_signature command .)


state 95

    (18) expression -> NOT expression .
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for MODULUS resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for STRING resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for NOT resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for NUMBER resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 18 (expression -> NOT expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 18 (expression -> NOT expression .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       reduce using rule 18 (expression -> NOT expression .)
    RPAREN          reduce using rule 18 (expression -> NOT expression .)
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! LOGICAL_AND     [ reduce using rule 18 (expression -> NOT expression .) ]
  ! LOGICAL_OR      [ reduce using rule 18 (expression -> NOT expression .) ]
  ! PLUS            [ reduce using rule 18 (expression -> NOT expression .) ]
  ! MINUS           [ reduce using rule 18 (expression -> NOT expression .) ]
  ! TIMES           [ reduce using rule 18 (expression -> NOT expression .) ]
  ! DIVIDE          [ reduce using rule 18 (expression -> NOT expression .) ]
  ! MODULUS         [ reduce using rule 18 (expression -> NOT expression .) ]
  ! EQUALS_THEN     [ reduce using rule 18 (expression -> NOT expression .) ]
  ! NOT_EQUALS      [ reduce using rule 18 (expression -> NOT expression .) ]
  ! GREATER_THEN    [ reduce using rule 18 (expression -> NOT expression .) ]
  ! LESS_THEN       [ reduce using rule 18 (expression -> NOT expression .) ]
  ! LESS_EQUALS     [ reduce using rule 18 (expression -> NOT expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 18 (expression -> NOT expression .) ]
  ! LPAREN          [ reduce using rule 18 (expression -> NOT expression .) ]
  ! IDENTIFIER      [ reduce using rule 18 (expression -> NOT expression .) ]
  ! STRING          [ reduce using rule 18 (expression -> NOT expression .) ]
  ! CHARACTER       [ reduce using rule 18 (expression -> NOT expression .) ]
  ! NOT             [ reduce using rule 18 (expression -> NOT expression .) ]
  ! NUMBER          [ reduce using rule 18 (expression -> NOT expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 18 (expression -> NOT expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 18 (expression -> NOT expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 18 (expression -> NOT expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 18 (expression -> NOT expression .) ]
  ! TYPE_CHAR       [ reduce using rule 18 (expression -> NOT expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 18 (expression -> NOT expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 18 (expression -> NOT expression .) ]
  ! TYPE_INT        [ reduce using rule 18 (expression -> NOT expression .) ]
  ! TYPE_LONG       [ reduce using rule 18 (expression -> NOT expression .) ]
  ! TYPE_SHORT      [ reduce using rule 18 (expression -> NOT expression .) ]
  ! TYPE_VOID       [ reduce using rule 18 (expression -> NOT expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 18 (expression -> NOT expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]
  ! SEMICOLON       [ reduce using rule 40 (expression2 -> expression .) ]
  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 96

    (30) expression2 -> TIMES expression .
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for MODULUS resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for STRING resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for NOT resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for NUMBER resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 30 (expression2 -> TIMES expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 30 (expression2 -> TIMES expression .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       reduce using rule 30 (expression2 -> TIMES expression .)
    RPAREN          reduce using rule 30 (expression2 -> TIMES expression .)
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! LOGICAL_AND     [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! LOGICAL_OR      [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! PLUS            [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! MINUS           [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! TIMES           [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! DIVIDE          [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! MODULUS         [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! EQUALS_THEN     [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! NOT_EQUALS      [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! GREATER_THEN    [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! LESS_THEN       [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! LESS_EQUALS     [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! LPAREN          [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! IDENTIFIER      [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! STRING          [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! CHARACTER       [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! NOT             [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! NUMBER          [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! TYPE_CHAR       [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! TYPE_INT        [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! TYPE_LONG       [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! TYPE_SHORT      [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! TYPE_VOID       [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 30 (expression2 -> TIMES expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]
  ! SEMICOLON       [ reduce using rule 40 (expression2 -> expression .) ]
  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 97

    (20) while_signature -> KEYWORD_WHILE LPAREN . expression RPAREN
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    NOT             shift and go to state 43
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

    expression                     shift and go to state 123
    expression2                    shift and go to state 42
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 98

    (39) expression2 -> LPAREN expression . RPAREN
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    RPAREN          shift and go to state 124
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 99

    (26) expression2 -> LOGICAL_AND expression .
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for MODULUS resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for STRING resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for NOT resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for NUMBER resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 26 (expression2 -> LOGICAL_AND expression .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       reduce using rule 26 (expression2 -> LOGICAL_AND expression .)
    RPAREN          reduce using rule 26 (expression2 -> LOGICAL_AND expression .)
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! LOGICAL_AND     [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! LOGICAL_OR      [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! PLUS            [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! MINUS           [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! TIMES           [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! DIVIDE          [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! MODULUS         [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! EQUALS_THEN     [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! NOT_EQUALS      [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! GREATER_THEN    [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! LESS_THEN       [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! LESS_EQUALS     [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! LPAREN          [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! IDENTIFIER      [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! STRING          [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! CHARACTER       [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! NOT             [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! NUMBER          [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! TYPE_CHAR       [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! TYPE_INT        [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! TYPE_LONG       [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! TYPE_SHORT      [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! TYPE_VOID       [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 26 (expression2 -> LOGICAL_AND expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]
  ! SEMICOLON       [ reduce using rule 40 (expression2 -> expression .) ]
  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 100

    (27) expression2 -> LOGICAL_OR expression .
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for MODULUS resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for STRING resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for NOT resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for NUMBER resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 27 (expression2 -> LOGICAL_OR expression .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       reduce using rule 27 (expression2 -> LOGICAL_OR expression .)
    RPAREN          reduce using rule 27 (expression2 -> LOGICAL_OR expression .)
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! LOGICAL_AND     [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! LOGICAL_OR      [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! PLUS            [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! MINUS           [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! TIMES           [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! DIVIDE          [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! MODULUS         [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! EQUALS_THEN     [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! NOT_EQUALS      [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! GREATER_THEN    [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! LESS_THEN       [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! LESS_EQUALS     [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! LPAREN          [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! IDENTIFIER      [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! STRING          [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! CHARACTER       [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! NOT             [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! NUMBER          [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! TYPE_CHAR       [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! TYPE_INT        [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! TYPE_LONG       [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! TYPE_SHORT      [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! TYPE_VOID       [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 27 (expression2 -> LOGICAL_OR expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]
  ! SEMICOLON       [ reduce using rule 40 (expression2 -> expression .) ]
  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 101

    (28) expression2 -> PLUS expression .
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for MODULUS resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for STRING resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for NOT resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for NUMBER resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 28 (expression2 -> PLUS expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 28 (expression2 -> PLUS expression .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       reduce using rule 28 (expression2 -> PLUS expression .)
    RPAREN          reduce using rule 28 (expression2 -> PLUS expression .)
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! LOGICAL_AND     [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! LOGICAL_OR      [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! PLUS            [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! MINUS           [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! TIMES           [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! MODULUS         [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! EQUALS_THEN     [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! NOT_EQUALS      [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! GREATER_THEN    [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! LESS_THEN       [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! LESS_EQUALS     [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! LPAREN          [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! IDENTIFIER      [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! STRING          [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! CHARACTER       [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! NOT             [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! NUMBER          [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! TYPE_CHAR       [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! TYPE_INT        [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! TYPE_LONG       [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! TYPE_SHORT      [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! TYPE_VOID       [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 28 (expression2 -> PLUS expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]
  ! SEMICOLON       [ reduce using rule 40 (expression2 -> expression .) ]
  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 102

    (29) expression2 -> MINUS expression .
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for MODULUS resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for STRING resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for NOT resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for NUMBER resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 29 (expression2 -> MINUS expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 29 (expression2 -> MINUS expression .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       reduce using rule 29 (expression2 -> MINUS expression .)
    RPAREN          reduce using rule 29 (expression2 -> MINUS expression .)
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! LOGICAL_AND     [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! LOGICAL_OR      [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! PLUS            [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! MINUS           [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! TIMES           [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! MODULUS         [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! EQUALS_THEN     [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! NOT_EQUALS      [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! GREATER_THEN    [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! LESS_THEN       [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! LESS_EQUALS     [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! LPAREN          [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! IDENTIFIER      [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! STRING          [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! CHARACTER       [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! NOT             [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! NUMBER          [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! TYPE_CHAR       [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! TYPE_INT        [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! TYPE_LONG       [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! TYPE_SHORT      [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! TYPE_VOID       [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 29 (expression2 -> MINUS expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]
  ! SEMICOLON       [ reduce using rule 40 (expression2 -> expression .) ]
  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 103

    (31) expression2 -> DIVIDE expression .
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for MODULUS resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for STRING resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for NOT resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for NUMBER resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 31 (expression2 -> DIVIDE expression .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       reduce using rule 31 (expression2 -> DIVIDE expression .)
    RPAREN          reduce using rule 31 (expression2 -> DIVIDE expression .)
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! LOGICAL_AND     [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! LOGICAL_OR      [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! PLUS            [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! TIMES           [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! DIVIDE          [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! MODULUS         [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! EQUALS_THEN     [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! NOT_EQUALS      [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! GREATER_THEN    [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! LESS_THEN       [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! LESS_EQUALS     [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! LPAREN          [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! IDENTIFIER      [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! STRING          [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! CHARACTER       [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! NOT             [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! NUMBER          [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! TYPE_CHAR       [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! TYPE_INT        [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! TYPE_LONG       [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! TYPE_SHORT      [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! TYPE_VOID       [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 31 (expression2 -> DIVIDE expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]
  ! SEMICOLON       [ reduce using rule 40 (expression2 -> expression .) ]
  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 104

    (32) expression2 -> MODULUS expression .
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for MODULUS resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for STRING resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for NOT resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for NUMBER resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 32 (expression2 -> MODULUS expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (expression2 -> MODULUS expression .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       reduce using rule 32 (expression2 -> MODULUS expression .)
    RPAREN          reduce using rule 32 (expression2 -> MODULUS expression .)
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! LOGICAL_AND     [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! LOGICAL_OR      [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! PLUS            [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! MINUS           [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! TIMES           [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! DIVIDE          [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! MODULUS         [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! EQUALS_THEN     [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! NOT_EQUALS      [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! GREATER_THEN    [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! LESS_THEN       [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! LESS_EQUALS     [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! LPAREN          [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! IDENTIFIER      [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! STRING          [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! CHARACTER       [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! NOT             [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! NUMBER          [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! TYPE_CHAR       [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! TYPE_INT        [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! TYPE_LONG       [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! TYPE_SHORT      [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! TYPE_VOID       [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 32 (expression2 -> MODULUS expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]
  ! SEMICOLON       [ reduce using rule 40 (expression2 -> expression .) ]
  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 105

    (33) expression2 -> EQUALS_THEN expression .
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for MODULUS resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for STRING resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for NOT resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for NUMBER resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 33 (expression2 -> EQUALS_THEN expression .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       reduce using rule 33 (expression2 -> EQUALS_THEN expression .)
    RPAREN          reduce using rule 33 (expression2 -> EQUALS_THEN expression .)
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! LOGICAL_AND     [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! LOGICAL_OR      [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! PLUS            [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! MINUS           [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! TIMES           [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! DIVIDE          [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! MODULUS         [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! EQUALS_THEN     [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! NOT_EQUALS      [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! GREATER_THEN    [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! LESS_THEN       [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! LESS_EQUALS     [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! LPAREN          [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! IDENTIFIER      [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! STRING          [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! CHARACTER       [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! NOT             [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! NUMBER          [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! TYPE_CHAR       [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! TYPE_INT        [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! TYPE_LONG       [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! TYPE_SHORT      [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! TYPE_VOID       [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 33 (expression2 -> EQUALS_THEN expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]
  ! SEMICOLON       [ reduce using rule 40 (expression2 -> expression .) ]
  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 106

    (34) expression2 -> NOT_EQUALS expression .
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for MODULUS resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for STRING resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for NOT resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for NUMBER resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 34 (expression2 -> NOT_EQUALS expression .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       reduce using rule 34 (expression2 -> NOT_EQUALS expression .)
    RPAREN          reduce using rule 34 (expression2 -> NOT_EQUALS expression .)
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! LOGICAL_AND     [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! LOGICAL_OR      [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! PLUS            [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! MINUS           [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! TIMES           [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! DIVIDE          [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! MODULUS         [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! EQUALS_THEN     [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! NOT_EQUALS      [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! GREATER_THEN    [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! LESS_THEN       [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! LESS_EQUALS     [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! LPAREN          [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! IDENTIFIER      [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! STRING          [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! CHARACTER       [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! NOT             [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! NUMBER          [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! TYPE_CHAR       [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! TYPE_INT        [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! TYPE_LONG       [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! TYPE_SHORT      [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! TYPE_VOID       [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 34 (expression2 -> NOT_EQUALS expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]
  ! SEMICOLON       [ reduce using rule 40 (expression2 -> expression .) ]
  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 107

    (35) expression2 -> GREATER_THEN expression .
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for MODULUS resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for STRING resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for NOT resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for NUMBER resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 35 (expression2 -> GREATER_THEN expression .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       reduce using rule 35 (expression2 -> GREATER_THEN expression .)
    RPAREN          reduce using rule 35 (expression2 -> GREATER_THEN expression .)
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! LOGICAL_AND     [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! LOGICAL_OR      [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! PLUS            [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! MINUS           [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! TIMES           [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! DIVIDE          [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! MODULUS         [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! EQUALS_THEN     [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! NOT_EQUALS      [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! GREATER_THEN    [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! LESS_THEN       [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! LESS_EQUALS     [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! LPAREN          [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! IDENTIFIER      [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! STRING          [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! CHARACTER       [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! NOT             [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! NUMBER          [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! TYPE_CHAR       [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! TYPE_INT        [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! TYPE_LONG       [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! TYPE_SHORT      [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! TYPE_VOID       [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 35 (expression2 -> GREATER_THEN expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]
  ! SEMICOLON       [ reduce using rule 40 (expression2 -> expression .) ]
  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 108

    (36) expression2 -> LESS_THEN expression .
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for MODULUS resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for STRING resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for NOT resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for NUMBER resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 36 (expression2 -> LESS_THEN expression .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       reduce using rule 36 (expression2 -> LESS_THEN expression .)
    RPAREN          reduce using rule 36 (expression2 -> LESS_THEN expression .)
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! LOGICAL_AND     [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! LOGICAL_OR      [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! PLUS            [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! MINUS           [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! TIMES           [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! DIVIDE          [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! MODULUS         [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! EQUALS_THEN     [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! NOT_EQUALS      [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! GREATER_THEN    [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! LESS_THEN       [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! LESS_EQUALS     [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! LPAREN          [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! IDENTIFIER      [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! STRING          [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! CHARACTER       [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! NOT             [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! NUMBER          [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! TYPE_CHAR       [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! TYPE_INT        [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! TYPE_LONG       [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! TYPE_SHORT      [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! TYPE_VOID       [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 36 (expression2 -> LESS_THEN expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]
  ! SEMICOLON       [ reduce using rule 40 (expression2 -> expression .) ]
  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 109

    (37) expression2 -> LESS_EQUALS expression .
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for MODULUS resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for STRING resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for NOT resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for NUMBER resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 37 (expression2 -> LESS_EQUALS expression .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       reduce using rule 37 (expression2 -> LESS_EQUALS expression .)
    RPAREN          reduce using rule 37 (expression2 -> LESS_EQUALS expression .)
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! LOGICAL_AND     [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! LOGICAL_OR      [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! PLUS            [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! MINUS           [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! TIMES           [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! DIVIDE          [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! MODULUS         [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! EQUALS_THEN     [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! NOT_EQUALS      [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! GREATER_THEN    [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! LESS_THEN       [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! LESS_EQUALS     [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! LPAREN          [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! IDENTIFIER      [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! STRING          [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! CHARACTER       [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! NOT             [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! NUMBER          [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! TYPE_CHAR       [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! TYPE_INT        [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! TYPE_LONG       [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! TYPE_SHORT      [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! TYPE_VOID       [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 37 (expression2 -> LESS_EQUALS expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]
  ! SEMICOLON       [ reduce using rule 40 (expression2 -> expression .) ]
  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 110

    (38) expression2 -> GREATER_EQUALS expression .
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for MODULUS resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for STRING resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for NOT resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for NUMBER resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 38 (expression2 -> GREATER_EQUALS expression .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       reduce using rule 38 (expression2 -> GREATER_EQUALS expression .)
    RPAREN          reduce using rule 38 (expression2 -> GREATER_EQUALS expression .)
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! LOGICAL_AND     [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! LOGICAL_OR      [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! PLUS            [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! MINUS           [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! TIMES           [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! DIVIDE          [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! MODULUS         [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! EQUALS_THEN     [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! NOT_EQUALS      [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! GREATER_THEN    [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! LESS_THEN       [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! LESS_EQUALS     [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! LPAREN          [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! IDENTIFIER      [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! STRING          [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! CHARACTER       [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! NOT             [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! NUMBER          [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! TYPE_CHAR       [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! TYPE_INT        [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! TYPE_LONG       [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! TYPE_SHORT      [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! TYPE_VOID       [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 38 (expression2 -> GREATER_EQUALS expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]
  ! SEMICOLON       [ reduce using rule 40 (expression2 -> expression .) ]
  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 111

    (55) function_parameters -> LPAREN parameters_list . RPAREN

    RPAREN          shift and go to state 125


state 112

    (56) function_parameters -> LPAREN RPAREN .

    SEMICOLON       reduce using rule 56 (function_parameters -> LPAREN RPAREN .)
    LBRACE          reduce using rule 56 (function_parameters -> LPAREN RPAREN .)


state 113

    (57) parameters_list -> data_definition . COMMA parameters_list
    (58) parameters_list -> data_definition .

    COMMA           shift and go to state 126
    RPAREN          reduce using rule 58 (parameters_list -> data_definition .)


state 114

    (59) parameters_list -> array_definition . COMMA parameters_list
    (60) parameters_list -> array_definition .

    COMMA           shift and go to state 127
    RPAREN          reduce using rule 60 (parameters_list -> array_definition .)


state 115

    (61) parameters_list -> array_declaration . COMMA parameters_list
    (62) parameters_list -> array_declaration .

    COMMA           shift and go to state 128
    RPAREN          reduce using rule 62 (parameters_list -> array_declaration .)


state 116

    (65) data_definition -> type . IDENTIFIER
    (63) array_declaration -> type . IDENTIFIER LBRACKET RBRACKET
    (84) pointer -> type . TIMES multiple_pointer
    (85) pointer -> type . TIMES
    (69) static_array_definition -> type . IDENTIFIER LBRACKET NUMBER RBRACKET
    (71) runtime_array_definition -> type . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    IDENTIFIER      shift and go to state 129
    TIMES           shift and go to state 24


state 117

    (66) data_definition -> pointer . IDENTIFIER
    (64) array_declaration -> pointer . IDENTIFIER LBRACKET RBRACKET
    (70) static_array_definition -> pointer . IDENTIFIER LBRACKET NUMBER RBRACKET
    (72) runtime_array_definition -> pointer . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    IDENTIFIER      shift and go to state 130


state 118

    (86) multiple_pointer -> TIMES multiple_pointer .

    IDENTIFIER      reduce using rule 86 (multiple_pointer -> TIMES multiple_pointer .)


state 119

    (23) assign -> IDENTIFIER . ASSIGN expression

    ASSIGN          shift and go to state 90


state 120

    (69) static_array_definition -> type IDENTIFIER LBRACKET . NUMBER RBRACKET
    (71) runtime_array_definition -> type IDENTIFIER LBRACKET . IDENTIFIER RBRACKET

    NUMBER          shift and go to state 132
    IDENTIFIER      shift and go to state 131


state 121

    (23) assign -> IDENTIFIER ASSIGN expression .
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for MODULUS resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for EQUALS_THEN resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for GREATER_THEN resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for LESS_THEN resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for LESS_EQUALS resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for GREATER_EQUALS resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for STRING resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for CHARACTER resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for NOT resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for NUMBER resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for FLOAT_NUMBER resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for BINARY_NUMBER resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for HEXADECIMAL_NUMBER resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for OCTAL_NUMBER resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for TYPE_FLOAT resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for TYPE_LONG resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for TYPE_SHORT resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for TYPE_VOID resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for KEYWORD_STRUCT resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    SEMICOLON       reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
    RPAREN          reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .)
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! LOGICAL_AND     [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! LOGICAL_OR      [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! PLUS            [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! TIMES           [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! DIVIDE          [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! MODULUS         [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! EQUALS_THEN     [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! NOT_EQUALS      [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! GREATER_THEN    [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! LESS_THEN       [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! LESS_EQUALS     [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! LPAREN          [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! IDENTIFIER      [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! STRING          [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! CHARACTER       [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! NOT             [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! NUMBER          [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! TYPE_CHAR       [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! TYPE_INT        [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! TYPE_LONG       [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! TYPE_SHORT      [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! TYPE_VOID       [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 23 (assign -> IDENTIFIER ASSIGN expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]
  ! SEMICOLON       [ reduce using rule 40 (expression2 -> expression .) ]
  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 122

    (70) static_array_definition -> pointer IDENTIFIER LBRACKET . NUMBER RBRACKET
    (72) runtime_array_definition -> pointer IDENTIFIER LBRACKET . IDENTIFIER RBRACKET

    NUMBER          shift and go to state 134
    IDENTIFIER      shift and go to state 133


state 123

    (20) while_signature -> KEYWORD_WHILE LPAREN expression . RPAREN
    (17) expression -> expression . expression2
    (40) expression2 -> expression .
    (26) expression2 -> . LOGICAL_AND expression
    (27) expression2 -> . LOGICAL_OR expression
    (28) expression2 -> . PLUS expression
    (29) expression2 -> . MINUS expression
    (30) expression2 -> . TIMES expression
    (31) expression2 -> . DIVIDE expression
    (32) expression2 -> . MODULUS expression
    (33) expression2 -> . EQUALS_THEN expression
    (34) expression2 -> . NOT_EQUALS expression
    (35) expression2 -> . GREATER_THEN expression
    (36) expression2 -> . LESS_THEN expression
    (37) expression2 -> . LESS_EQUALS expression
    (38) expression2 -> . GREATER_EQUALS expression
    (39) expression2 -> . LPAREN expression RPAREN
    (40) expression2 -> . expression
    (41) expression2 -> . IDENTIFIER
    (42) expression2 -> . number
    (43) expression2 -> . STRING
    (44) expression2 -> . CHARACTER
    (45) expression2 -> . assign
    (46) expression2 -> . define_and_assign
    (17) expression -> . expression expression2
    (18) expression -> . NOT expression
    (19) expression -> . expression2
    (47) number -> . NUMBER
    (48) number -> . FLOAT_NUMBER
    (49) number -> . BINARY_NUMBER
    (50) number -> . HEXADECIMAL_NUMBER
    (51) number -> . OCTAL_NUMBER
    (23) assign -> . IDENTIFIER ASSIGN expression
    (24) define_and_assign -> . type assign
    (25) define_and_assign -> . pointer assign
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for EQUALS_THEN resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_THEN resolved as shift
  ! shift/reduce conflict for LESS_THEN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT_NUMBER resolved as shift
  ! shift/reduce conflict for BINARY_NUMBER resolved as shift
  ! shift/reduce conflict for HEXADECIMAL_NUMBER resolved as shift
  ! shift/reduce conflict for OCTAL_NUMBER resolved as shift
  ! shift/reduce conflict for TYPE_CHAR resolved as shift
  ! shift/reduce conflict for TYPE_DOUBLE resolved as shift
  ! shift/reduce conflict for TYPE_FLOAT resolved as shift
  ! shift/reduce conflict for TYPE_INT resolved as shift
  ! shift/reduce conflict for TYPE_LONG resolved as shift
  ! shift/reduce conflict for TYPE_SHORT resolved as shift
  ! shift/reduce conflict for TYPE_VOID resolved as shift
  ! shift/reduce conflict for KEYWORD_STRUCT resolved as shift
    RPAREN          shift and go to state 135
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 53
    MODULUS         shift and go to state 54
    EQUALS_THEN     shift and go to state 55
    NOT_EQUALS      shift and go to state 56
    GREATER_THEN    shift and go to state 57
    LESS_THEN       shift and go to state 58
    LESS_EQUALS     shift and go to state 59
    GREATER_EQUALS  shift and go to state 60
    LPAREN          shift and go to state 48
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 62
    CHARACTER       shift and go to state 63
    NOT             shift and go to state 43
    NUMBER          shift and go to state 64
    FLOAT_NUMBER    shift and go to state 65
    BINARY_NUMBER   shift and go to state 66
    HEXADECIMAL_NUMBER shift and go to state 67
    OCTAL_NUMBER    shift and go to state 68
    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    KEYWORD_STRUCT  shift and go to state 17

  ! RPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 40 (expression2 -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 40 (expression2 -> expression .) ]
  ! PLUS            [ reduce using rule 40 (expression2 -> expression .) ]
  ! MINUS           [ reduce using rule 40 (expression2 -> expression .) ]
  ! TIMES           [ reduce using rule 40 (expression2 -> expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression2 -> expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression2 -> expression .) ]
  ! EQUALS_THEN     [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT_EQUALS      [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_THEN    [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_THEN       [ reduce using rule 40 (expression2 -> expression .) ]
  ! LESS_EQUALS     [ reduce using rule 40 (expression2 -> expression .) ]
  ! GREATER_EQUALS  [ reduce using rule 40 (expression2 -> expression .) ]
  ! LPAREN          [ reduce using rule 40 (expression2 -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 40 (expression2 -> expression .) ]
  ! STRING          [ reduce using rule 40 (expression2 -> expression .) ]
  ! CHARACTER       [ reduce using rule 40 (expression2 -> expression .) ]
  ! NOT             [ reduce using rule 40 (expression2 -> expression .) ]
  ! NUMBER          [ reduce using rule 40 (expression2 -> expression .) ]
  ! FLOAT_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! BINARY_NUMBER   [ reduce using rule 40 (expression2 -> expression .) ]
  ! HEXADECIMAL_NUMBER [ reduce using rule 40 (expression2 -> expression .) ]
  ! OCTAL_NUMBER    [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_CHAR       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_DOUBLE     [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_FLOAT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_INT        [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_LONG       [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_SHORT      [ reduce using rule 40 (expression2 -> expression .) ]
  ! TYPE_VOID       [ reduce using rule 40 (expression2 -> expression .) ]
  ! KEYWORD_STRUCT  [ reduce using rule 40 (expression2 -> expression .) ]

    expression                     shift and go to state 79
    expression2                    shift and go to state 81
    number                         shift and go to state 61
    assign                         shift and go to state 83
    define_and_assign              shift and go to state 84
    type                           shift and go to state 85
    pointer                        shift and go to state 86
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 124

    (39) expression2 -> LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    LOGICAL_AND     reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    LOGICAL_OR      reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    MODULUS         reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    EQUALS_THEN     reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    NOT_EQUALS      reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    GREATER_THEN    reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    LESS_THEN       reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    LESS_EQUALS     reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    GREATER_EQUALS  reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    STRING          reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    CHARACTER       reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    NOT             reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    NUMBER          reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    FLOAT_NUMBER    reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    BINARY_NUMBER   reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    HEXADECIMAL_NUMBER reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    OCTAL_NUMBER    reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    TYPE_CHAR       reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    TYPE_DOUBLE     reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    TYPE_FLOAT      reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    TYPE_INT        reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    TYPE_LONG       reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    TYPE_SHORT      reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    TYPE_VOID       reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    KEYWORD_STRUCT  reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 39 (expression2 -> LPAREN expression RPAREN .)


state 125

    (55) function_parameters -> LPAREN parameters_list RPAREN .

    SEMICOLON       reduce using rule 55 (function_parameters -> LPAREN parameters_list RPAREN .)
    LBRACE          reduce using rule 55 (function_parameters -> LPAREN parameters_list RPAREN .)


state 126

    (57) parameters_list -> data_definition COMMA . parameters_list
    (57) parameters_list -> . data_definition COMMA parameters_list
    (58) parameters_list -> . data_definition
    (59) parameters_list -> . array_definition COMMA parameters_list
    (60) parameters_list -> . array_definition
    (61) parameters_list -> . array_declaration COMMA parameters_list
    (62) parameters_list -> . array_declaration
    (65) data_definition -> . type IDENTIFIER
    (66) data_definition -> . pointer IDENTIFIER
    (67) array_definition -> . static_array_definition
    (68) array_definition -> . runtime_array_definition
    (63) array_declaration -> . type IDENTIFIER LBRACKET RBRACKET
    (64) array_declaration -> . pointer IDENTIFIER LBRACKET RBRACKET
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (69) static_array_definition -> . type IDENTIFIER LBRACKET NUMBER RBRACKET
    (70) static_array_definition -> . pointer IDENTIFIER LBRACKET NUMBER RBRACKET
    (71) runtime_array_definition -> . type IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (72) runtime_array_definition -> . pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    IDENTIFIER      shift and go to state 6
    KEYWORD_STRUCT  shift and go to state 17

    data_definition                shift and go to state 113
    parameters_list                shift and go to state 136
    array_definition               shift and go to state 114
    array_declaration              shift and go to state 115
    type                           shift and go to state 116
    pointer                        shift and go to state 117
    static_array_definition        shift and go to state 44
    runtime_array_definition       shift and go to state 45
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 127

    (59) parameters_list -> array_definition COMMA . parameters_list
    (57) parameters_list -> . data_definition COMMA parameters_list
    (58) parameters_list -> . data_definition
    (59) parameters_list -> . array_definition COMMA parameters_list
    (60) parameters_list -> . array_definition
    (61) parameters_list -> . array_declaration COMMA parameters_list
    (62) parameters_list -> . array_declaration
    (65) data_definition -> . type IDENTIFIER
    (66) data_definition -> . pointer IDENTIFIER
    (67) array_definition -> . static_array_definition
    (68) array_definition -> . runtime_array_definition
    (63) array_declaration -> . type IDENTIFIER LBRACKET RBRACKET
    (64) array_declaration -> . pointer IDENTIFIER LBRACKET RBRACKET
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (69) static_array_definition -> . type IDENTIFIER LBRACKET NUMBER RBRACKET
    (70) static_array_definition -> . pointer IDENTIFIER LBRACKET NUMBER RBRACKET
    (71) runtime_array_definition -> . type IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (72) runtime_array_definition -> . pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    IDENTIFIER      shift and go to state 6
    KEYWORD_STRUCT  shift and go to state 17

    array_definition               shift and go to state 114
    parameters_list                shift and go to state 137
    data_definition                shift and go to state 113
    array_declaration              shift and go to state 115
    type                           shift and go to state 116
    pointer                        shift and go to state 117
    static_array_definition        shift and go to state 44
    runtime_array_definition       shift and go to state 45
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 128

    (61) parameters_list -> array_declaration COMMA . parameters_list
    (57) parameters_list -> . data_definition COMMA parameters_list
    (58) parameters_list -> . data_definition
    (59) parameters_list -> . array_definition COMMA parameters_list
    (60) parameters_list -> . array_definition
    (61) parameters_list -> . array_declaration COMMA parameters_list
    (62) parameters_list -> . array_declaration
    (65) data_definition -> . type IDENTIFIER
    (66) data_definition -> . pointer IDENTIFIER
    (67) array_definition -> . static_array_definition
    (68) array_definition -> . runtime_array_definition
    (63) array_declaration -> . type IDENTIFIER LBRACKET RBRACKET
    (64) array_declaration -> . pointer IDENTIFIER LBRACKET RBRACKET
    (73) type -> . primitive_types
    (74) type -> . user_types
    (84) pointer -> . type TIMES multiple_pointer
    (85) pointer -> . type TIMES
    (69) static_array_definition -> . type IDENTIFIER LBRACKET NUMBER RBRACKET
    (70) static_array_definition -> . pointer IDENTIFIER LBRACKET NUMBER RBRACKET
    (71) runtime_array_definition -> . type IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (72) runtime_array_definition -> . pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET
    (75) primitive_types -> . TYPE_CHAR
    (76) primitive_types -> . TYPE_DOUBLE
    (77) primitive_types -> . TYPE_FLOAT
    (78) primitive_types -> . TYPE_INT
    (79) primitive_types -> . TYPE_LONG
    (80) primitive_types -> . TYPE_SHORT
    (81) primitive_types -> . TYPE_VOID
    (82) user_types -> . IDENTIFIER
    (83) user_types -> . KEYWORD_STRUCT IDENTIFIER

    TYPE_CHAR       shift and go to state 10
    TYPE_DOUBLE     shift and go to state 11
    TYPE_FLOAT      shift and go to state 12
    TYPE_INT        shift and go to state 13
    TYPE_LONG       shift and go to state 14
    TYPE_SHORT      shift and go to state 15
    TYPE_VOID       shift and go to state 16
    IDENTIFIER      shift and go to state 6
    KEYWORD_STRUCT  shift and go to state 17

    array_declaration              shift and go to state 115
    parameters_list                shift and go to state 138
    data_definition                shift and go to state 113
    array_definition               shift and go to state 114
    type                           shift and go to state 116
    pointer                        shift and go to state 117
    static_array_definition        shift and go to state 44
    runtime_array_definition       shift and go to state 45
    primitive_types                shift and go to state 8
    user_types                     shift and go to state 9

state 129

    (65) data_definition -> type IDENTIFIER .
    (63) array_declaration -> type IDENTIFIER . LBRACKET RBRACKET
    (69) static_array_definition -> type IDENTIFIER . LBRACKET NUMBER RBRACKET
    (71) runtime_array_definition -> type IDENTIFIER . LBRACKET IDENTIFIER RBRACKET

    COMMA           reduce using rule 65 (data_definition -> type IDENTIFIER .)
    RPAREN          reduce using rule 65 (data_definition -> type IDENTIFIER .)
    LBRACKET        shift and go to state 139


state 130

    (66) data_definition -> pointer IDENTIFIER .
    (64) array_declaration -> pointer IDENTIFIER . LBRACKET RBRACKET
    (70) static_array_definition -> pointer IDENTIFIER . LBRACKET NUMBER RBRACKET
    (72) runtime_array_definition -> pointer IDENTIFIER . LBRACKET IDENTIFIER RBRACKET

    COMMA           reduce using rule 66 (data_definition -> pointer IDENTIFIER .)
    RPAREN          reduce using rule 66 (data_definition -> pointer IDENTIFIER .)
    LBRACKET        shift and go to state 140


state 131

    (71) runtime_array_definition -> type IDENTIFIER LBRACKET IDENTIFIER . RBRACKET

    RBRACKET        shift and go to state 141


state 132

    (69) static_array_definition -> type IDENTIFIER LBRACKET NUMBER . RBRACKET

    RBRACKET        shift and go to state 142


state 133

    (72) runtime_array_definition -> pointer IDENTIFIER LBRACKET IDENTIFIER . RBRACKET

    RBRACKET        shift and go to state 143


state 134

    (70) static_array_definition -> pointer IDENTIFIER LBRACKET NUMBER . RBRACKET

    RBRACKET        shift and go to state 144


state 135

    (20) while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .

    LBRACE          reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    NOT             reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    KEYWORD_WHILE   reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    LOGICAL_AND     reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    LOGICAL_OR      reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    PLUS            reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    MINUS           reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    TIMES           reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    MODULUS         reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    EQUALS_THEN     reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    NOT_EQUALS      reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    GREATER_THEN    reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    LESS_THEN       reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    LESS_EQUALS     reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    GREATER_EQUALS  reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    LPAREN          reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    STRING          reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    CHARACTER       reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    TYPE_CHAR       reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    TYPE_DOUBLE     reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    TYPE_FLOAT      reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    TYPE_INT        reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    TYPE_LONG       reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    TYPE_SHORT      reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    TYPE_VOID       reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    KEYWORD_STRUCT  reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    NUMBER          reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    FLOAT_NUMBER    reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    BINARY_NUMBER   reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    HEXADECIMAL_NUMBER reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)
    OCTAL_NUMBER    reduce using rule 20 (while_signature -> KEYWORD_WHILE LPAREN expression RPAREN .)


state 136

    (57) parameters_list -> data_definition COMMA parameters_list .

    RPAREN          reduce using rule 57 (parameters_list -> data_definition COMMA parameters_list .)


state 137

    (59) parameters_list -> array_definition COMMA parameters_list .

    RPAREN          reduce using rule 59 (parameters_list -> array_definition COMMA parameters_list .)


state 138

    (61) parameters_list -> array_declaration COMMA parameters_list .

    RPAREN          reduce using rule 61 (parameters_list -> array_declaration COMMA parameters_list .)


state 139

    (63) array_declaration -> type IDENTIFIER LBRACKET . RBRACKET
    (69) static_array_definition -> type IDENTIFIER LBRACKET . NUMBER RBRACKET
    (71) runtime_array_definition -> type IDENTIFIER LBRACKET . IDENTIFIER RBRACKET

    RBRACKET        shift and go to state 145
    NUMBER          shift and go to state 132
    IDENTIFIER      shift and go to state 131


state 140

    (64) array_declaration -> pointer IDENTIFIER LBRACKET . RBRACKET
    (70) static_array_definition -> pointer IDENTIFIER LBRACKET . NUMBER RBRACKET
    (72) runtime_array_definition -> pointer IDENTIFIER LBRACKET . IDENTIFIER RBRACKET

    RBRACKET        shift and go to state 146
    NUMBER          shift and go to state 134
    IDENTIFIER      shift and go to state 133


state 141

    (71) runtime_array_definition -> type IDENTIFIER LBRACKET IDENTIFIER RBRACKET .

    SEMICOLON       reduce using rule 71 (runtime_array_definition -> type IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    COMMA           reduce using rule 71 (runtime_array_definition -> type IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    RPAREN          reduce using rule 71 (runtime_array_definition -> type IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)


state 142

    (69) static_array_definition -> type IDENTIFIER LBRACKET NUMBER RBRACKET .

    SEMICOLON       reduce using rule 69 (static_array_definition -> type IDENTIFIER LBRACKET NUMBER RBRACKET .)
    COMMA           reduce using rule 69 (static_array_definition -> type IDENTIFIER LBRACKET NUMBER RBRACKET .)
    RPAREN          reduce using rule 69 (static_array_definition -> type IDENTIFIER LBRACKET NUMBER RBRACKET .)


state 143

    (72) runtime_array_definition -> pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET .

    SEMICOLON       reduce using rule 72 (runtime_array_definition -> pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    COMMA           reduce using rule 72 (runtime_array_definition -> pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    RPAREN          reduce using rule 72 (runtime_array_definition -> pointer IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)


state 144

    (70) static_array_definition -> pointer IDENTIFIER LBRACKET NUMBER RBRACKET .

    SEMICOLON       reduce using rule 70 (static_array_definition -> pointer IDENTIFIER LBRACKET NUMBER RBRACKET .)
    COMMA           reduce using rule 70 (static_array_definition -> pointer IDENTIFIER LBRACKET NUMBER RBRACKET .)
    RPAREN          reduce using rule 70 (static_array_definition -> pointer IDENTIFIER LBRACKET NUMBER RBRACKET .)


state 145

    (63) array_declaration -> type IDENTIFIER LBRACKET RBRACKET .

    COMMA           reduce using rule 63 (array_declaration -> type IDENTIFIER LBRACKET RBRACKET .)
    RPAREN          reduce using rule 63 (array_declaration -> type IDENTIFIER LBRACKET RBRACKET .)


state 146

    (64) array_declaration -> pointer IDENTIFIER LBRACKET RBRACKET .

    COMMA           reduce using rule 64 (array_declaration -> pointer IDENTIFIER LBRACKET RBRACKET .)
    RPAREN          reduce using rule 64 (array_declaration -> pointer IDENTIFIER LBRACKET RBRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMICOLON in state 33 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 34 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 35 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 35 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 35 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 35 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 35 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 35 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 35 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 35 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 35 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 35 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 35 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 35 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 35 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 35 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 35 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 35 resolved as shift
WARNING: shift/reduce conflict for STRING in state 35 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 35 resolved as shift
WARNING: shift/reduce conflict for NOT in state 35 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 35 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 35 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 35 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 35 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 35 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 35 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 35 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 35 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 35 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 35 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 35 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 35 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 35 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 79 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 79 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 79 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 79 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 79 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 79 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 79 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 79 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 79 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 79 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 79 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 79 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 79 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 79 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 79 resolved as shift
WARNING: shift/reduce conflict for STRING in state 79 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 79 resolved as shift
WARNING: shift/reduce conflict for NOT in state 79 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 79 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 79 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 79 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 79 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 79 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 79 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 79 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 79 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 79 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 79 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 79 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 79 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 79 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 95 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 95 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 95 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 95 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 95 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 95 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 95 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 95 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 95 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 95 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 95 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 95 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 95 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 95 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 95 resolved as shift
WARNING: shift/reduce conflict for STRING in state 95 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 95 resolved as shift
WARNING: shift/reduce conflict for NOT in state 95 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 95 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 95 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 95 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 95 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 95 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 95 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 95 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 95 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 95 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 95 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 95 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 95 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 95 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 96 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 96 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 96 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 96 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 96 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 96 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 96 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 96 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 96 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 96 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 96 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 96 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 96 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 96 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 96 resolved as shift
WARNING: shift/reduce conflict for STRING in state 96 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 96 resolved as shift
WARNING: shift/reduce conflict for NOT in state 96 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 96 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 96 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 96 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 96 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 96 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 96 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 96 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 96 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 96 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 96 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 96 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 96 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 96 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 98 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 98 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 98 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 98 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 98 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 98 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 98 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 98 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 98 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 98 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 98 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 98 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 98 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 98 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 98 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 98 resolved as shift
WARNING: shift/reduce conflict for STRING in state 98 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 98 resolved as shift
WARNING: shift/reduce conflict for NOT in state 98 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 98 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 98 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 98 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 98 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 98 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 98 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 98 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 98 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 98 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 98 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 98 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 98 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 98 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 99 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 99 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 99 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 99 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 99 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 99 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 99 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 99 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 99 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 99 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 99 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 99 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 99 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 99 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 99 resolved as shift
WARNING: shift/reduce conflict for STRING in state 99 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 99 resolved as shift
WARNING: shift/reduce conflict for NOT in state 99 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 99 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 99 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 99 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 99 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 99 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 99 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 99 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 99 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 99 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 99 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 99 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 99 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 99 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 100 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 100 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 100 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 100 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 100 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 100 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 100 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 100 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 100 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 100 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 100 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 100 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 100 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 100 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 100 resolved as shift
WARNING: shift/reduce conflict for STRING in state 100 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 100 resolved as shift
WARNING: shift/reduce conflict for NOT in state 100 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 100 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 100 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 100 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 100 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 100 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 100 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 100 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 100 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 100 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 100 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 100 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 100 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 100 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 101 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 101 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 101 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 101 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 101 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 101 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 101 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 101 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 101 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 101 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 101 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 101 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 101 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 101 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 101 resolved as shift
WARNING: shift/reduce conflict for STRING in state 101 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 101 resolved as shift
WARNING: shift/reduce conflict for NOT in state 101 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 101 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 101 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 101 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 101 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 101 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 101 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 101 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 101 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 101 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 101 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 101 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 101 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 101 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 102 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 102 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 102 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 102 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 102 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 102 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 102 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 102 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 102 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 102 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 102 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 102 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 102 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 102 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 102 resolved as shift
WARNING: shift/reduce conflict for STRING in state 102 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 102 resolved as shift
WARNING: shift/reduce conflict for NOT in state 102 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 102 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 102 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 102 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 102 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 102 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 102 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 102 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 102 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 102 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 102 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 102 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 102 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 102 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 103 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 103 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 103 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 103 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 103 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 103 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 103 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 103 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 103 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 103 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 103 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 103 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 103 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 103 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 103 resolved as shift
WARNING: shift/reduce conflict for STRING in state 103 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 103 resolved as shift
WARNING: shift/reduce conflict for NOT in state 103 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 103 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 103 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 103 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 103 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 103 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 103 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 103 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 103 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 103 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 103 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 103 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 103 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 103 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 104 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 104 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 104 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 104 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 104 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 104 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 104 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 104 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 104 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 104 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 104 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 104 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 104 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 104 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 104 resolved as shift
WARNING: shift/reduce conflict for STRING in state 104 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 104 resolved as shift
WARNING: shift/reduce conflict for NOT in state 104 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 104 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 104 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 104 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 104 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 104 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 104 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 104 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 104 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 104 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 104 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 104 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 104 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 104 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 105 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 105 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 105 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 105 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 105 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 105 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 105 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 105 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 105 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 105 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 105 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 105 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 105 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 105 resolved as shift
WARNING: shift/reduce conflict for STRING in state 105 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 105 resolved as shift
WARNING: shift/reduce conflict for NOT in state 105 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 105 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 105 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 105 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 105 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 105 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 105 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 105 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 105 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 105 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 105 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 105 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 105 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 105 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 106 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 106 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 106 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 106 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 106 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 106 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 106 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 106 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 106 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 106 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 106 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 106 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 106 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 106 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 106 resolved as shift
WARNING: shift/reduce conflict for STRING in state 106 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 106 resolved as shift
WARNING: shift/reduce conflict for NOT in state 106 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 106 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 106 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 106 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 106 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 106 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 106 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 106 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 106 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 106 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 106 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 106 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 106 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 106 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 107 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 107 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 107 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 107 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 107 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 107 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 107 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 107 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 107 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 107 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 107 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 107 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 107 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 107 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 107 resolved as shift
WARNING: shift/reduce conflict for STRING in state 107 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 107 resolved as shift
WARNING: shift/reduce conflict for NOT in state 107 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 107 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 107 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 107 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 107 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 107 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 107 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 107 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 107 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 107 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 107 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 107 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 107 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 107 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 108 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 108 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 108 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 108 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 108 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 108 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 108 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 108 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 108 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 108 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 108 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 108 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 108 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 108 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 108 resolved as shift
WARNING: shift/reduce conflict for STRING in state 108 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 108 resolved as shift
WARNING: shift/reduce conflict for NOT in state 108 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 108 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 108 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 108 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 108 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 108 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 108 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 108 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 108 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 108 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 108 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 108 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 108 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 108 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 109 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 109 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 109 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 109 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 109 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 109 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 109 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 109 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 109 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 109 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 109 resolved as shift
WARNING: shift/reduce conflict for STRING in state 109 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 109 resolved as shift
WARNING: shift/reduce conflict for NOT in state 109 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 109 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 109 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 109 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 109 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 109 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 109 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 109 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 109 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 109 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 109 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 109 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 109 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 109 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 110 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 110 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 110 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 110 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 110 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 110 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 110 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 110 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 110 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 110 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 110 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 110 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 110 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 110 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 110 resolved as shift
WARNING: shift/reduce conflict for STRING in state 110 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 110 resolved as shift
WARNING: shift/reduce conflict for NOT in state 110 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 110 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 110 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 110 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 110 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 110 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 110 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 110 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 110 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 110 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 110 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 110 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 110 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 110 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 121 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 121 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 121 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 121 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 121 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 121 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 121 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 121 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 121 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 121 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 121 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 121 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 121 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 121 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 121 resolved as shift
WARNING: shift/reduce conflict for STRING in state 121 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 121 resolved as shift
WARNING: shift/reduce conflict for NOT in state 121 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 121 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 121 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 121 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 121 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 121 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 121 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 121 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 121 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 121 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 121 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 121 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 121 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 121 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 123 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 123 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 123 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 123 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 123 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 123 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 123 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 123 resolved as shift
WARNING: shift/reduce conflict for EQUALS_THEN in state 123 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 123 resolved as shift
WARNING: shift/reduce conflict for GREATER_THEN in state 123 resolved as shift
WARNING: shift/reduce conflict for LESS_THEN in state 123 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS in state 123 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS in state 123 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 123 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 123 resolved as shift
WARNING: shift/reduce conflict for STRING in state 123 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 123 resolved as shift
WARNING: shift/reduce conflict for NOT in state 123 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 123 resolved as shift
WARNING: shift/reduce conflict for FLOAT_NUMBER in state 123 resolved as shift
WARNING: shift/reduce conflict for BINARY_NUMBER in state 123 resolved as shift
WARNING: shift/reduce conflict for HEXADECIMAL_NUMBER in state 123 resolved as shift
WARNING: shift/reduce conflict for OCTAL_NUMBER in state 123 resolved as shift
WARNING: shift/reduce conflict for TYPE_CHAR in state 123 resolved as shift
WARNING: shift/reduce conflict for TYPE_DOUBLE in state 123 resolved as shift
WARNING: shift/reduce conflict for TYPE_FLOAT in state 123 resolved as shift
WARNING: shift/reduce conflict for TYPE_INT in state 123 resolved as shift
WARNING: shift/reduce conflict for TYPE_LONG in state 123 resolved as shift
WARNING: shift/reduce conflict for TYPE_SHORT in state 123 resolved as shift
WARNING: shift/reduce conflict for TYPE_VOID in state 123 resolved as shift
WARNING: shift/reduce conflict for KEYWORD_STRUCT in state 123 resolved as shift
WARNING: reduce/reduce conflict in state 39 resolved using rule (expression2 -> IDENTIFIER)
WARNING: rejected rule (user_types -> IDENTIFIER) in state 39
WARNING: reduce/reduce conflict in state 81 resolved using rule (expression -> expression expression2)
WARNING: rejected rule (expression -> expression2) in state 81
WARNING: reduce/reduce conflict in state 82 resolved using rule (expression2 -> IDENTIFIER)
WARNING: rejected rule (user_types -> IDENTIFIER) in state 82
WARNING: reduce/reduce conflict in state 93 resolved using rule (command -> command_block)
WARNING: rejected rule (while_loop -> while_signature command_block) in state 93
WARNING: reduce/reduce conflict in state 95 resolved using rule (expression -> NOT expression)
WARNING: rejected rule (expression2 -> expression) in state 95
WARNING: reduce/reduce conflict in state 96 resolved using rule (expression2 -> TIMES expression)
WARNING: rejected rule (expression2 -> expression) in state 96
WARNING: reduce/reduce conflict in state 99 resolved using rule (expression2 -> LOGICAL_AND expression)
WARNING: rejected rule (expression2 -> expression) in state 99
WARNING: reduce/reduce conflict in state 100 resolved using rule (expression2 -> LOGICAL_OR expression)
WARNING: rejected rule (expression2 -> expression) in state 100
WARNING: reduce/reduce conflict in state 101 resolved using rule (expression2 -> PLUS expression)
WARNING: rejected rule (expression2 -> expression) in state 101
WARNING: reduce/reduce conflict in state 102 resolved using rule (expression2 -> MINUS expression)
WARNING: rejected rule (expression2 -> expression) in state 102
WARNING: reduce/reduce conflict in state 103 resolved using rule (expression2 -> DIVIDE expression)
WARNING: rejected rule (expression2 -> expression) in state 103
WARNING: reduce/reduce conflict in state 104 resolved using rule (expression2 -> MODULUS expression)
WARNING: rejected rule (expression2 -> expression) in state 104
WARNING: reduce/reduce conflict in state 105 resolved using rule (expression2 -> EQUALS_THEN expression)
WARNING: rejected rule (expression2 -> expression) in state 105
WARNING: reduce/reduce conflict in state 106 resolved using rule (expression2 -> NOT_EQUALS expression)
WARNING: rejected rule (expression2 -> expression) in state 106
WARNING: reduce/reduce conflict in state 107 resolved using rule (expression2 -> GREATER_THEN expression)
WARNING: rejected rule (expression2 -> expression) in state 107
WARNING: reduce/reduce conflict in state 108 resolved using rule (expression2 -> LESS_THEN expression)
WARNING: rejected rule (expression2 -> expression) in state 108
WARNING: reduce/reduce conflict in state 109 resolved using rule (expression2 -> LESS_EQUALS expression)
WARNING: rejected rule (expression2 -> expression) in state 109
WARNING: reduce/reduce conflict in state 110 resolved using rule (expression2 -> GREATER_EQUALS expression)
WARNING: rejected rule (expression2 -> expression) in state 110
WARNING: reduce/reduce conflict in state 121 resolved using rule (assign -> IDENTIFIER ASSIGN expression)
WARNING: rejected rule (expression2 -> expression) in state 121
WARNING: Rule (while_loop -> while_signature command_block) is never reduced
